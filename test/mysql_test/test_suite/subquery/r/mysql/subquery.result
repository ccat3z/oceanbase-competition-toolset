create database if not exists test;
use test;
drop table if exists t1, t2, t3;
create table t1(c1 int primary key, c2 int);
create table t2(c1 int primary key, c2 int);
create table t3(c1 int primary key, c2 int);
insert into t1 values(1, 1), (2, 2), (3, 3), (4, 3), (5, 2);
insert into t2 values(1, 1), (2, 2);
insert into t3 values(5, 5), (6, 6);
select * from t1 where c1>ANY(select c1 from t2);
c1	c2
2	2
3	3
4	3
5	2
select * from t1 where c1<ALL(select c1 from t2);
c1	c2
select * from t1 where c1=(select c1 from t2);
ERROR 21000: Subquery returns more than 1 row
select * from t1 where c1=(select c1 from t2 limit 1);
c1	c2
1	1
select * from t1 where c1=ANY(select c1 from t2 where t1.c2>t2.c2);
c1	c2
select * from t1 where exists(select c1 from t2 where t1.c2>t2.c2);
c1	c2
2	2
3	3
4	3
5	2
select * from t1 where 1<ANY(select c1 from t2);
c1	c2
1	1
2	2
3	3
4	3
5	2
select c2 from t1 where exists(select c2 from t2 where t1.c1>t2.c1);
c2
2
3
3
2
select * from t1 where c1>(select c1 from t2 where t2.c1=1);
c1	c2
2	2
3	3
4	3
5	2
select * from t1 where exists(select * from t2 where t1.c1=t2.c2);
c1	c2
1	1
2	2
select * from t1 where c1 in (select c1 from t1);
c1	c2
1	1
2	2
3	3
4	3
5	2
select * from t1 where c1 not in (select c1 from t1);
c1	c2
select c1 from t1 where c1 not in (select c1 from t2 where c2 not in (select c2 from t2));
c1
1
2
3
4
5
select * from (select * from t1 limit 1) t;
c1	c2
1	1
select c from (select c1 as c from t1) tt;
c
1
2
3
4
5
select c1 from t1 where c1 in (select c1 from t2 where c2 >= some(select max(c1) from (select c1 from t3 where t1.c2=t3.c1 order by c1 limit 1) as tt));
c1
select (select c1, c2 from t1) from t1;
ERROR 21000: Operand should contain 1 column(s)
select (select c1 from t1) from t1;
ERROR 21000: Subquery returns more than 1 row
select (select c1 from t1 where c1=1) from t1;
(select c1 from t1 where c1=1)
1
1
1
1
1
select (select 1)=ANY(select 1);
(select 1)=ANY(select 1)
1
SELECT (SELECT 1)>ALL(SELECT 1);
(SELECT 1)>ALL(SELECT 1)
0
SELECT (SELECT 1,2,3) = ROW(1,2,3);
(SELECT 1,2,3) = ROW(1,2,3)
1
SELECT (SELECT 1,2,3) = ROW(1,2,1);
(SELECT 1,2,3) = ROW(1,2,1)
0
SELECT (SELECT 1,2,3) < ROW(1,2,1);
(SELECT 1,2,3) < ROW(1,2,1)
0
SELECT (SELECT 1,2,3) > ROW(1,2,1);
(SELECT 1,2,3) > ROW(1,2,1)
1
SELECT (SELECT 1,2,3) = ROW(1,2,NULL);
(SELECT 1,2,3) = ROW(1,2,NULL)
NULL
SELECT ROW(1,2,3) = (SELECT 1,2,3);
ROW(1,2,3) = (SELECT 1,2,3)
1
SELECT ROW(1,2,3) = (SELECT 1,2,1);
ROW(1,2,3) = (SELECT 1,2,1)
0
SELECT ROW(1,2,3) < (SELECT 1,2,1);
ROW(1,2,3) < (SELECT 1,2,1)
0
SELECT ROW(1,2,3) > (SELECT 1,2,1);
ROW(1,2,3) > (SELECT 1,2,1)
1
SELECT ROW(1,2,3) = (SELECT 1,2,NULL);
ROW(1,2,3) = (SELECT 1,2,NULL)
NULL
SELECT (SELECT 1.5,2,'a') = ROW(1.5,2,'a');
(SELECT 1.5,2,'a') = ROW(1.5,2,'a')
1
SELECT (SELECT 1.5,2,'a') = ROW(1.5,2,'b');
(SELECT 1.5,2,'a') = ROW(1.5,2,'b')
0
SELECT (SELECT 1.5,2,'a') = ROW(1.5,'2','a');
(SELECT 1.5,2,'a') = ROW(1.5,'2','a')
1
SELECT (SELECT 1.5,'c','a') = ROW(1.5,2,'a');
(SELECT 1.5,'c','a') = ROW(1.5,2,'a')
0
select (select 3, 2, 1)>row(1, 2, 1);
(select 3, 2, 1)>row(1, 2, 1)
1
select (select 1, 2, 3)>row(1, 2, 1);
(select 1, 2, 3)>row(1, 2, 1)
1
select (select 1, 2, 3)>row(1, 2, 3);
(select 1, 2, 3)>row(1, 2, 3)
0
select (select 1, 3, 2)>row(1, 2, 3);
(select 1, 3, 2)>row(1, 2, 3)
1
select (select 1, 2, 3)>row(1, 3, 2);
(select 1, 2, 3)>row(1, 3, 2)
0
select (select 1, null, 2)>row(1, 2, 2);
(select 1, null, 2)>row(1, 2, 2)
NULL
select (select 1, 2, null)>row(1, 1, 2);
(select 1, 2, null)>row(1, 1, 2)
1
select (select 3, 2, 1)>=row(1, 2, 1);
(select 3, 2, 1)>=row(1, 2, 1)
1
select (select 1, 2, 3)>=row(1, 2, 1);
(select 1, 2, 3)>=row(1, 2, 1)
1
select (select 1, 2, 3)>=row(1, 2, 3);
(select 1, 2, 3)>=row(1, 2, 3)
1
select (select 1, 3, 2)>=row(1, 2, 3);
(select 1, 3, 2)>=row(1, 2, 3)
1
select (select 1, 2, 3)>=row(1, 3, 2);
(select 1, 2, 3)>=row(1, 3, 2)
0
select (select 1, null, 2)>=row(1, 2, 2);
(select 1, null, 2)>=row(1, 2, 2)
NULL
select (select 1, 2, null)>=row(1, 1, 2);
(select 1, 2, null)>=row(1, 1, 2)
1
select (select 1, 2, 3)<row(3, 2, 1);
(select 1, 2, 3)<row(3, 2, 1)
1
select (select 1, 2, 3)<row(1, 3, 2);
(select 1, 2, 3)<row(1, 3, 2)
1
select (select 1, 2, 1)<row(1, 2, 3);
(select 1, 2, 1)<row(1, 2, 3)
1
select (select 1, 2, 3)<row(1, 2, 3);
(select 1, 2, 3)<row(1, 2, 3)
0
select (select 1, 3, 2)<row(1, 2, 3);
(select 1, 3, 2)<row(1, 2, 3)
0
select (select 1, null, 2)<row(1, 2, 2);
(select 1, null, 2)<row(1, 2, 2)
NULL
select (select 1, 2, null)<row(1, 1, 2);
(select 1, 2, null)<row(1, 1, 2)
0
select (select 1, 2, 3)<=row(3, 2, 1);
(select 1, 2, 3)<=row(3, 2, 1)
1
select (select 1, 2, 3)<=row(1, 3, 2);
(select 1, 2, 3)<=row(1, 3, 2)
1
select (select 1, 2, 1)<=row(1, 2, 3);
(select 1, 2, 1)<=row(1, 2, 3)
1
select (select 1, 2, 3)<=row(1, 2, 3);
(select 1, 2, 3)<=row(1, 2, 3)
1
select (select 1, 3, 2)<=row(1, 2, 3);
(select 1, 3, 2)<=row(1, 2, 3)
0
select (select 1, null, 2)<=row(1, 2, 2);
(select 1, null, 2)<=row(1, 2, 2)
NULL
select (select 1, 2, null)<=row(1, 1, 2);
(select 1, 2, null)<=row(1, 1, 2)
0
select (select 1, 2, 3)=row(1, 2, 3);
(select 1, 2, 3)=row(1, 2, 3)
1
select (select 1, 2, 3)=row(1, 2, 1);
(select 1, 2, 3)=row(1, 2, 1)
0
select (select 1, 2, 1)=row(3, 2, 1);
(select 1, 2, 1)=row(3, 2, 1)
0
select (select 1, null, 1)=row(1, 2, 1);
(select 1, null, 1)=row(1, 2, 1)
NULL
select (select 1, 2, 3)<=>row(1, 2, 3);
(select 1, 2, 3)<=>row(1, 2, 3)
1
select (select 1, 2, 3)<=>row(1, 2, 1);
(select 1, 2, 3)<=>row(1, 2, 1)
0
select (select 1, null, 1)<=>row(1, 2, 1);
(select 1, null, 1)<=>row(1, 2, 1)
0
select (select 1, null, 3)<=>row(1, null, 3);
(select 1, null, 3)<=>row(1, null, 3)
1
select (select 1, 2, 3)!=row(1, 2, 3);
(select 1, 2, 3)!=row(1, 2, 3)
0
select (select 1, 2, 3)!=row(1, 2, 1);
(select 1, 2, 3)!=row(1, 2, 1)
1
select (select 1, null, 1)!=row(1, 2, 1);
(select 1, null, 1)!=row(1, 2, 1)
NULL
select (select 1, null, 3)!=row(1, null, 3);
(select 1, null, 3)!=row(1, null, 3)
NULL
select * from t1 group by (select c1 from t1 limit 1);
c1	c2
1	1
select * from t1 group by (select c1, c2 from t1);
ERROR 21000: Operand should contain 1 column(s)
delete from t1;
insert into t1 values(1, NULL), (2, NULL), (3, NULL), (4, NULL);
select NULL=ANY(select c1 from t1);
NULL=ANY(select c1 from t1)
NULL
select NULL=ALL(select c1 from t1);
NULL=ALL(select c1 from t1)
NULL
delete from t1;
insert into t1 values(1, NULL), (2, 2), (3, 3), (4, 4);
select 2=ANY(select c2 from t1);
2=ANY(select c2 from t1)
1
select 2=ALL(select c2 from t1);
2=ALL(select c2 from t1)
0
select 5=ANY(select c2 from t1);
5=ANY(select c2 from t1)
NULL
select 5!=ANY(select c2 from t1);
5!=ANY(select c2 from t1)
1
delete from t1;
insert into t1 values(1, 1), (2, NULL), (3, 3), (4, 4);
select 1=ANY(select c1 from t1);
1=ANY(select c1 from t1)
1
select 1!=ANY(select c1 from t1);
1!=ANY(select c1 from t1)
1
select 1=ALL(select c1 from t1);
1=ALL(select c1 from t1)
0
select 1!=ALL(select c1 from t1);
1!=ALL(select c1 from t1)
0
select 5=ANY(select c1 from t1);
5=ANY(select c1 from t1)
0
select 5!=ANY(select c1 from t1);
5!=ANY(select c1 from t1)
1
select 5=ALL(select c1 from t1);
5=ALL(select c1 from t1)
0
select 5!=ALL(select c1 from t1);
5!=ALL(select c1 from t1)
1
delete from t1;
insert into t1 values(1, 1), (2, 2), (3, 3), (4, NULL);
select 1!=ANY(select c1 from t1);
1!=ANY(select c1 from t1)
1
select 1=ANY(select c1 from t1);
1=ANY(select c1 from t1)
1
select 1!=ALL(select c1 from t1);
1!=ALL(select c1 from t1)
0
select 1=ALL(select c1 from t1);
1=ALL(select c1 from t1)
0
select 5!=ANY(select c1 from t1);
5!=ANY(select c1 from t1)
1
select 5=ANY(select c1 from t1);
5=ANY(select c1 from t1)
0
select 5!=ALL(select c1 from t1);
5!=ALL(select c1 from t1)
1
select 5=ALL(select c1 from t1);
5=ALL(select c1 from t1)
0
select * from t1 where c1 > (select t2.c1 from t2 where t1.c1  limit 1);
c1	c2
2	2
3	3
4	NULL
select t1.c1 from t1 left join t3 on t1.c1 = t3.c1 where t3.c1 < (select t2.c1 from t2 where t3.c1  limit 1);
c1
select * from t1 where c1 > (select t2.c1 from t2 where t1.c1 > 1 limit 1);
c1	c2
2	2
3	3
4	NULL
drop table if exists t1, t2;
create table t1 (a int not null, b int not null, index it1a(a), index iab(a, b));
create table t2 (c int not null, d int not null);
insert into t1 values (1,10);
insert into t1 values (1,20);
insert into t1 values (2,10);
insert into t1 values (2,20);
insert into t1 values (2,30);
insert into t1 values (3,20);
insert into t1 values (4,40);
insert into t2 values (2,10);
insert into t2 values (2,20);
insert into t2 values (2,40);
insert into t2 values (3,20);
insert into t2 values (4,10);
insert into t2 values (5,10);
select a from t1 group by a having a in (select c from t2 where d >= 20);
a
2
3
drop table if exists t1;
create table t1(c1 int);
select count(1) from t1 where false;
count(1)
0
select count(1) from t1 having false;
count(1)
select count(1) from t1 group by c1 having false;
count(1)
select count(1) from t1 where false group by c1;
count(1)
insert into t1 values(1);
select * from t1 where c1 in (trim((select 1)), 2);
c1
1
select * from t1 where c1 in ((select c1 from t1), 2);
c1
1
select * from t1 where c1 in ((select t1.c1 from t1 t), 2);
c1
1
drop table if exists t1, t2;
drop table if exists DD,AA,J,CC,GG;
CREATE TABLE DD ( col_int int, pk int, col_varchar_20 varchar(20), col_int_key int, primary key (pk));
CREATE TABLE AA ( pk int, col_int_key int, col_varchar_20 varchar(20), col_int int, primary key (pk));
CREATE TABLE J (  col_varchar_20 varchar(20), pk int primary key);
CREATE TABLE CC ( col_int_key int, pk int, col_int int, col_varchar_20 varchar(20), primary key (pk));
CREATE TABLE GG (col_varchar_20 varchar(20), pk int primary key);
insert into DD (pk, col_varchar_20, col_int, col_int_key) value(1, "YYY", 5,3);
insert into AA (pk, col_varchar_20, col_int, col_int_key) value(2, 'me', 4, 3);
insert into CC (pk, col_varchar_20, col_int) value(3, 'you', 4);
SELECT  GRANDPARENT1 . col_varchar_20 AS G1 FROM DD AS GRANDPARENT1 WHERE GRANDPARENT1 . `col_int_key` IN ( SELECT DISTINCT PARENT1 . `col_int_key` AS P1 FROM AA AS PARENT1 LEFT JOIN J AS PARENT2 USING ( col_varchar_20 ) WHERE PARENT1 . `col_int` IN ( SELECT  CHILD1 . `col_int` AS C1 FROM CC AS CHILD1 LEFT JOIN GG AS CHILD2 USING ( col_varchar_20 )  )  AND ( GRANDPARENT1 . `col_int` >= 1 ));
G1
YYY
drop table if exists DD,AA,J,CC,GG;
drop table if exists t1, t2, t3;
create table t1(c1 int primary key, c2 int, c3 int);
create table t2(c1 int primary key, c2 int, c3 int);
create table t3(c1 int primary key, c2 int, c3 int);
insert into t1 values(1, 2, 3);
insert into t1 values(2, 2, 3);
insert into t2 values(1, 2, 3);
insert into t2 values(2, 2, 3);
insert into t3 values(1, 2, 3);
insert into t3 values(2, 2, 3);
explain basic select * from t1 where t1.c2 = 5 or exists (select 1 from t2 where t1.c1 = t2.c1);
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | TABLE SCAN   |t1  |
|2 | TABLE GET    |t2  |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter([t1.c2 = 5 OR (T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1 where t1.c2 = 5 or exists (select 1 from t2 where t1.c1 > t2.c1);
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | TABLE SCAN   |t1  |
|2 | TABLE SCAN   |t2  |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter([t1.c2 = 5 OR (T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1 where t1.c2 = 5 or exists (select 1 from t2 where t1.c1 < t2.c1);
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | TABLE SCAN   |t1  |
|2 | TABLE SCAN   |t2  |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter([t1.c2 = 5 OR (T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1, t2 where t1.c1 > exists(select c1 from t2 where t2.c1 = t1.c1);
Query Plan
=====================================
|ID|OPERATOR                   |NAME|
-------------------------------------
|0 |SUBPLAN FILTER             |    |
|1 | NESTED-LOOP JOIN CARTESIAN|    |
|2 |  TABLE SCAN               |t1  |
|3 |  MATERIAL                 |    |
|4 |   TABLE SCAN              |t2  |
|5 | TABLE GET                 |t2  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t2.c1], [t2.c2], [t2.c3]), filter([t1.c1 > (T_OP_EXISTS, subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
  3 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil)
  4 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  5 - output([1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1 where (select c1 from t2 limit 1)+1 in (select 2 from t3 where t1.c1=t3.c1);
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | MERGE JOIN   |    |
|2 |  TABLE SCAN  |t1  |
|3 |  TABLE SCAN  |t3  |
|4 | TABLE SCAN   |t2  |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter([?]), 
      exec_params_(nil), onetime_exprs_([subquery(1) + 1 = 2]), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      equal_conds([t1.c1 = t3.c1]), other_conds(nil)
  2 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1 having count(*) > (select c1 from t2 where t1.c1=t2.c1);
Query Plan
==========================
|ID|OPERATOR        |NAME|
--------------------------
|0 |SUBPLAN FILTER  |    |
|1 | SCALAR GROUP BY|    |
|2 |  TABLE SCAN    |t1  |
|3 | TABLE GET      |t2  |
==========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter([T_FUN_COUNT(*) > subquery(1)]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3], [T_FUN_COUNT(*)]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(*)])
  2 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
  3 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

explain basic select * from t1, t2 where t2.c1 = t1.c1 and t2.c1 = (select c1 from t3 where t3.c1 = t1.c1);
Query Plan
======================
|ID|OPERATOR    |NAME|
----------------------
|0 |MERGE JOIN  |    |
|1 | MERGE JOIN |    |
|2 |  TABLE SCAN|t2  |
|3 |  TABLE SCAN|t3  |
|4 | TABLE SCAN |t1  |
======================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds(nil)
  1 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      equal_conds([t2.c1 = t3.c1]), other_conds(nil)
  2 - output([t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      access([t2.c1], [t2.c2], [t2.c3]), partitions(p0)
  3 - output([t3.c1]), filter(nil), 
      access([t3.c1]), partitions(p0)
  4 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)

explain basic select * from (select c1+1 as a1 from t1 where t1.c2 = 2) a, t2 where a.a1 = t2.c2 or t2.c1 = ANY(select c3 from t3 where t3.c1 > a.a1);
Query Plan
=====================================
|ID|OPERATOR                   |NAME|
-------------------------------------
|0 |SUBPLAN FILTER             |    |
|1 | NESTED-LOOP JOIN CARTESIAN|    |
|2 |  TABLE SCAN               |t2  |
|3 |  MATERIAL                 |    |
|4 |   TABLE SCAN              |t1  |
|5 | TABLE SCAN                |t3  |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1 + 1], [t2.c1], [t2.c2], [t2.c3]), filter([t1.c1 + 1 = t2.c2 OR t2.c1 = ANY(subquery(1))]), 
      exec_params_([t1.c1 + 1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t2.c1], [t2.c2], [t2.c3]), filter(nil), 
      conds(nil), nl_params_(nil)
  2 - output([t2.c2], [t2.c1], [t2.c3]), filter(nil), 
      access([t2.c2], [t2.c1], [t2.c3]), partitions(p0)
  3 - output([t1.c1]), filter(nil)
  4 - output([t1.c1]), filter([t1.c2 = 2]), 
      access([t1.c2], [t1.c1]), partitions(p0)
  5 - output([t3.c3]), filter(nil), 
      access([t3.c3]), partitions(p0)

select * from t1 where t1.c2 = 5 or exists (select 1 from t2 where t1.c1 = t2.c1);
c1	c2	c3
1	2	3
2	2	3
select * from t1 where t1.c2 = 5 or exists (select 1 from t2 where t1.c1 > t2.c1);
c1	c2	c3
2	2	3
select * from t1 where t1.c2 = 5 or exists (select 1 from t2 where t1.c1 < t2.c1);
c1	c2	c3
1	2	3
select * from t1, t2 where t1.c1 > exists(select c1 from t2 where t2.c1 = t1.c1);
c1	c2	c3	c1	c2	c3
2	2	3	1	2	3
2	2	3	2	2	3
select * from t1 where (select c1 from t2 limit 1)+1 in (select 2 from t3 where t1.c1=t3.c1);
c1	c2	c3
1	2	3
2	2	3
select * from t1 having count(*) > (select c1 from t2 where t1.c1=t2.c1);
c1	c2	c3
1	2	3
select * from t1, t2 where t2.c1 = t1.c1 and t2.c1 = (select c1 from t3 where t3.c1 = t1.c1);
c1	c2	c3	c1	c2	c3
1	2	3	1	2	3
2	2	3	2	2	3
select * from (select c1+1 as a1 from t1 where t1.c2 = 2) a, t2 where a.a1 = t2.c2 or t2.c1 = ANY(select c3 from t3 where t3.c1 > a.a1);
a1	c1	c2	c3
2	1	2	3
2	2	2	3
explain basic select * from t1 where t1.c1 > (select sum(c1) from t2 where t2.c1 = t1.c1);
Query Plan
=====================
|ID|OPERATOR   |NAME|
---------------------
|0 |MERGE JOIN |    |
|1 | TABLE SCAN|t1  |
|2 | TABLE SCAN|t2  |
=====================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds([cast(t1.c1, DECIMAL(11, 0)) > cast(t2.c1, DECIMAL(11, 0))])
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
  2 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)

explain basic select * from t1 where t1.c1 > (select sum(c1) from t2 where t2.c1 = t1.c1 and t2.c2 > (select max(c2) from t3 where t3.c1 = t2.c1));
Query Plan
==========================
|ID|OPERATOR        |NAME|
--------------------------
|0 |NESTED-LOOP JOIN|    |
|1 | MERGE JOIN     |    |
|2 |  TABLE SCAN    |t1  |
|3 |  TABLE SCAN    |t2  |
|4 | TABLE GET      |t3  |
==========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      conds(nil), nl_params_([t2.c2], [t2.c1])
  1 - output([t1.c1], [t1.c2], [t1.c3], [t2.c2], [t2.c1]), filter(nil), 
      equal_conds([t2.c1 = t1.c1]), other_conds([cast(t1.c1, DECIMAL(11, 0)) > cast(t2.c1, DECIMAL(11, 0))])
  2 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
  3 - output([t2.c1], [t2.c2]), filter(nil), 
      access([t2.c1], [t2.c2]), partitions(p0)
  4 - output([1]), filter([? > t3.c2]), 
      access([t3.c2]), partitions(p0)

explain basic select * from t1 where t1.c2 in (select avg(c1) from t2 where t2.c1 = t1.c1 union select count(1) from t3 where t3.c1 = t1.c1);
Query Plan
===============================
|ID|OPERATOR             |NAME|
-------------------------------
|0 |SUBPLAN FILTER       |    |
|1 | TABLE SCAN          |t1  |
|2 | MERGE UNION DISTINCT|    |
|3 |  SCALAR GROUP BY    |    |
|4 |   TABLE GET         |t2  |
|5 |  SCALAR GROUP BY    |    |
|6 |   TABLE GET         |t3  |
===============================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter([cast(t1.c2, DECIMAL(11, 0)) = ANY(subquery(1))]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
  2 - output([UNION([1])]), filter(nil)
  3 - output([T_FUN_SUM(t2.c1) / cast(T_FUN_COUNT(t2.c1), DECIMAL(20, 0))]), filter(nil), 
      group(nil), agg_func([T_FUN_SUM(t2.c1)], [T_FUN_COUNT(t2.c1)])
  4 - output([t2.c1]), filter(nil), 
      access([t2.c1]), partitions(p0)
  5 - output([cast(T_FUN_COUNT(1), DECIMAL(24, 4))]), filter(nil), 
      group(nil), agg_func([T_FUN_COUNT(1)])
  6 - output([1]), filter(nil), 
      access([t3.c1]), partitions(p0)

explain basic select * from t1 where t1.c1 != (select c2 from t2 where t2.c1 = (select max(c2) from t3 where t3.c1 = t1.c1) order by t2.c2 limit 1);
Query Plan
============================
|ID|OPERATOR          |NAME|
----------------------------
|0 |SUBPLAN FILTER    |    |
|1 | TABLE SCAN       |t1  |
|2 | LIMIT            |    |
|3 |  SUBPLAN FILTER  |    |
|4 |   TABLE GET      |t2  |
|5 |   SCALAR GROUP BY|    |
|6 |    TABLE GET     |t3  |
============================

Outputs & filters: 
-------------------------------------
  0 - output([t1.c1], [t1.c2], [t1.c3]), filter([t1.c1 != subquery(1)]), 
      exec_params_([t1.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t1.c1], [t1.c2], [t1.c3]), filter(nil), 
      access([t1.c1], [t1.c2], [t1.c3]), partitions(p0)
  2 - output([t2.c2]), filter(nil), limit(1), offset(nil)
  3 - output([t2.c2]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  4 - output([t2.c2]), filter(nil), 
      access([t2.c2]), partitions(p0)
  5 - output([T_FUN_MAX(t3.c2)]), filter(nil), 
      group(nil), agg_func([T_FUN_MAX(t3.c2)])
  6 - output([t3.c2]), filter(nil), 
      access([t3.c2]), partitions(p0)

select * from t1 where t1.c1 > (select sum(c1) from t2 where t2.c1 = t1.c1);
c1	c2	c3
select * from t1 where t1.c1 > (select sum(c1) from t2 where t2.c1 = t1.c1 and t2.c2 > (select max(c2) from t3 where t3.c1 = t2.c1));
c1	c2	c3
select * from t1 where t1.c2 in (select avg(c1) from t2 where t2.c1 = t1.c1 union select count(1) from t3 where t3.c1 = t1.c1);
c1	c2	c3
2	2	3
select * from t1 where t1.c1 != (select c2 from t2 where t2.c1 = (select max(c2) from t3 where t3.c1 = t1.c1) order by t2.c2 limit 1);
c1	c2	c3
1	2	3
drop table if exists t1, t2, t3;
drop table if exists t1,t2,t3;
create table t1(a int, b int);
create table t2(a int, b int);
create table t3(a int, b int);
explain basic select * from t1 where exists (select 1, round(1.1) from dual);
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | TABLE SCAN   |t1  |
|2 | LIMIT        |    |
|3 |  EXPRESSION  |    |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([1], [?]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil)
      values({1})

explain basic select * from t1 where exists (select max(a) from t2);
Query Plan
====================
|ID|OPERATOR  |NAME|
--------------------
|0 |TABLE SCAN|t1  |
====================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), startup_filter([1]), 
      access([t1.a], [t1.b]), partitions(p0)

explain basic select * from t1 where exists (select group_concat(a, b) from t2 group by a);
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | TABLE SCAN   |t1  |
|2 | TABLE SCAN   |t2  |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.__pk_increment]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1 where exists (select max(a), sum(a), count(a) from t2);
Query Plan
====================
|ID|OPERATOR  |NAME|
--------------------
|0 |TABLE SCAN|t1  |
====================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), startup_filter([1]), 
      access([t1.a], [t1.b]), partitions(p0)

explain basic select * from t1 where exists (select max(a), sum(a), count(a) from t2 group by a);
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | TABLE SCAN   |t1  |
|2 | TABLE SCAN   |t2  |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.__pk_increment]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1 where exists (select max(a), sum(a), count(a) from t2 group by a having a > 1);
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | TABLE SCAN   |t1  |
|2 | TABLE SCAN   |t2  |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([1]), filter([t2.a > 1]), 
      access([t2.a]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1 where exists (select max(a), sum(a), count(a) from t2 group by a having sum(a) > 1);
Query Plan
=========================
|ID|OPERATOR       |NAME|
-------------------------
|0 |SUBPLAN FILTER |    |
|1 | TABLE SCAN    |t1  |
|2 | LIMIT         |    |
|3 |  HASH GROUP BY|    |
|4 |   TABLE SCAN  |t2  |
=========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([T_FUN_MAX(t2.a)], [T_FUN_SUM(t2.a)], [T_FUN_COUNT(t2.a)]), filter(nil), limit(1), offset(nil)
  3 - output([T_FUN_MAX(t2.a)], [T_FUN_SUM(t2.a)], [T_FUN_COUNT(t2.a)]), filter([T_FUN_SUM(t2.a) > ?]), 
      group([t2.a]), agg_func([T_FUN_MAX(t2.a)], [T_FUN_SUM(t2.a)], [T_FUN_COUNT(t2.a)])
  4 - output([t2.a]), filter(nil), 
      access([t2.a]), partitions(p0)

explain basic select * from t1 where exists (select max(a), sum(a), count(a) from t2 group by a having sum(a) > 1 and count(a) > 0);
Query Plan
=========================
|ID|OPERATOR       |NAME|
-------------------------
|0 |SUBPLAN FILTER |    |
|1 | TABLE SCAN    |t1  |
|2 | LIMIT         |    |
|3 |  HASH GROUP BY|    |
|4 |   TABLE SCAN  |t2  |
=========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([T_FUN_MAX(t2.a)], [T_FUN_SUM(t2.a)], [T_FUN_COUNT(t2.a)]), filter(nil), limit(1), offset(nil)
  3 - output([T_FUN_MAX(t2.a)], [T_FUN_SUM(t2.a)], [T_FUN_COUNT(t2.a)]), filter([T_FUN_SUM(t2.a) > ?], [T_FUN_COUNT(t2.a) > 0]), 
      group([t2.a]), agg_func([T_FUN_MAX(t2.a)], [T_FUN_SUM(t2.a)], [T_FUN_COUNT(t2.a)])
  4 - output([t2.a]), filter(nil), 
      access([t2.a]), partitions(p0)

explain basic select * from t1 where not exists (select 1, round(1.1) from dual);
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | TABLE SCAN   |t1  |
|2 | LIMIT        |    |
|3 |  EXPRESSION  |    |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([1], [?]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil)
      values({1})

explain basic select * from t1 where not exists (select max(a) from t2);
Query Plan
====================
|ID|OPERATOR  |NAME|
--------------------
|0 |TABLE SCAN|t1  |
====================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), startup_filter([0]), 
      access([t1.a], [t1.b]), partitions(p0)

explain basic select * from t1 where not exists (select group_concat(a, b) from t2 group by a);
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | TABLE SCAN   |t1  |
|2 | TABLE SCAN   |t2  |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.__pk_increment]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1 where not exists (select max(a), sum(a), count(a) from t2);
Query Plan
====================
|ID|OPERATOR  |NAME|
--------------------
|0 |TABLE SCAN|t1  |
====================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), startup_filter([0]), 
      access([t1.a], [t1.b]), partitions(p0)

explain basic select * from t1 where not exists (select max(a), sum(a), count(a) from t2 group by a);
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | TABLE SCAN   |t1  |
|2 | TABLE SCAN   |t2  |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([1]), filter(nil), 
      access([t2.__pk_increment]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1 where not exists (select max(a), sum(a), count(a) from t2 group by a having a > 1);
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | TABLE SCAN   |t1  |
|2 | TABLE SCAN   |t2  |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([1]), filter([t2.a > 1]), 
      access([t2.a]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1 where not exists (select max(a), sum(a), count(a) from t2 group by a having sum(a) > 1);
Query Plan
=========================
|ID|OPERATOR       |NAME|
-------------------------
|0 |SUBPLAN FILTER |    |
|1 | TABLE SCAN    |t1  |
|2 | LIMIT         |    |
|3 |  HASH GROUP BY|    |
|4 |   TABLE SCAN  |t2  |
=========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([T_FUN_MAX(t2.a)], [T_FUN_SUM(t2.a)], [T_FUN_COUNT(t2.a)]), filter(nil), limit(1), offset(nil)
  3 - output([T_FUN_MAX(t2.a)], [T_FUN_SUM(t2.a)], [T_FUN_COUNT(t2.a)]), filter([T_FUN_SUM(t2.a) > ?]), 
      group([t2.a]), agg_func([T_FUN_MAX(t2.a)], [T_FUN_SUM(t2.a)], [T_FUN_COUNT(t2.a)])
  4 - output([t2.a]), filter(nil), 
      access([t2.a]), partitions(p0)

explain basic select * from t1 where not exists (select max(a), sum(a), count(a) from t2 group by a having sum(a) > 1 and count(a) > 0);
Query Plan
=========================
|ID|OPERATOR       |NAME|
-------------------------
|0 |SUBPLAN FILTER |    |
|1 | TABLE SCAN    |t1  |
|2 | LIMIT         |    |
|3 |  HASH GROUP BY|    |
|4 |   TABLE SCAN  |t2  |
=========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([T_FUN_MAX(t2.a)], [T_FUN_SUM(t2.a)], [T_FUN_COUNT(t2.a)]), filter(nil), limit(1), offset(nil)
  3 - output([T_FUN_MAX(t2.a)], [T_FUN_SUM(t2.a)], [T_FUN_COUNT(t2.a)]), filter([T_FUN_SUM(t2.a) > ?], [T_FUN_COUNT(t2.a) > 0]), 
      group([t2.a]), agg_func([T_FUN_MAX(t2.a)], [T_FUN_SUM(t2.a)], [T_FUN_COUNT(t2.a)])
  4 - output([t2.a]), filter(nil), 
      access([t2.a]), partitions(p0)

explain basic select * from t1, (select * from t2 where exists(select sum(a) from t3)) t4 where t1.a = t4.a;
Query Plan
=====================
|ID|OPERATOR   |NAME|
---------------------
|0 |HASH JOIN  |    |
|1 | TABLE SCAN|t1  |
|2 | TABLE SCAN|t2  |
=====================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t2.a], [t2.b]), filter(nil), 
      equal_conds([t1.a = t2.a]), other_conds(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)

explain basic select * from t1 where t1.a in (select a from t2 where exists(select count(a) from t3));
Query Plan
===============================
|ID|OPERATOR            |NAME |
-------------------------------
|0 |HASH RIGHT SEMI JOIN|     |
|1 | SUBPLAN SCAN       |VIEW1|
|2 |  TABLE SCAN        |t2   |
|3 | TABLE SCAN         |t1   |
===============================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      equal_conds([t1.a = VIEW1.a]), other_conds(nil)
  1 - output([VIEW1.a]), filter(nil), startup_filter([1]), 
      access([VIEW1.a])
  2 - output([t2.a]), filter(nil), 
      access([t2.a]), partitions(p0)
  3 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)

explain basic select * from t1 where exists(select max(a) from t2 group by a having max(a) > 1);
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | TABLE SCAN   |t1  |
|2 | TABLE SCAN   |t2  |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([1]), filter([t2.a > 1]), 
      access([t2.a]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1, (select * from t2 having a > 1) t4 where t1.a = t4.a;
Query Plan
=====================
|ID|OPERATOR   |NAME|
---------------------
|0 |HASH JOIN  |    |
|1 | TABLE SCAN|t1  |
|2 | TABLE SCAN|t2  |
=====================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t2.a], [t2.b]), filter(nil), 
      equal_conds([t1.a = t2.a]), other_conds(nil)
  1 - output([t1.a], [t1.b]), filter([t1.a > 1]), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([t2.a], [t2.b]), filter([t2.a > 1]), 
      access([t2.a], [t2.b]), partitions(p0)

explain basic select * from t1, (select * from t2 where exists(select sum(a) from t3 group by a having a > 1)) t4 where t1.a = t4.a;
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | HASH JOIN    |    |
|2 |  TABLE SCAN  |t1  |
|3 |  TABLE SCAN  |t2  |
|4 | TABLE SCAN   |t3  |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b], [t2.a], [t2.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b], [t2.a], [t2.b]), filter(nil), 
      equal_conds([t1.a = t2.a]), other_conds(nil)
  2 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  3 - output([t2.a], [t2.b]), filter(nil), 
      access([t2.a], [t2.b]), partitions(p0)
  4 - output([1]), filter([t3.a > 1]), 
      access([t3.a]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1 where exists ( select max(a) from t2 group by a having exists (select * from t3 where t3.a > max(t2.a)));
Query Plan
==========================
|ID|OPERATOR        |NAME|
--------------------------
|0 |SUBPLAN FILTER  |    |
|1 | TABLE SCAN     |t1  |
|2 | LIMIT          |    |
|3 |  SUBPLAN FILTER|    |
|4 |   HASH GROUP BY|    |
|5 |    TABLE SCAN  |t2  |
|6 |   TABLE SCAN   |t3  |
==========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([T_FUN_MAX(t2.a)]), filter(nil), limit(1), offset(nil)
  3 - output([T_FUN_MAX(t2.a)]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([T_FUN_MAX(t2.a)]), onetime_exprs_(nil), init_plan_idxs_(nil)
  4 - output([T_FUN_MAX(t2.a)]), filter(nil), 
      group([t2.a]), agg_func([T_FUN_MAX(t2.a)])
  5 - output([t2.a]), filter(nil), 
      access([t2.a]), partitions(p0)
  6 - output([t3.a], [t3.b]), filter([t3.a > ?]), 
      access([t3.a], [t3.b]), partitions(p0)

explain basic select * from t1 where exists ( select sum(a) from t2 group by a having exists (select * from t3 where t3.a > sum(t2.a)));
Query Plan
==========================
|ID|OPERATOR        |NAME|
--------------------------
|0 |SUBPLAN FILTER  |    |
|1 | TABLE SCAN     |t1  |
|2 | LIMIT          |    |
|3 |  SUBPLAN FILTER|    |
|4 |   HASH GROUP BY|    |
|5 |    TABLE SCAN  |t2  |
|6 |   TABLE SCAN   |t3  |
==========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.a], [t1.b]), filter(nil), 
      access([t1.a], [t1.b]), partitions(p0)
  2 - output([T_FUN_SUM(t2.a)]), filter(nil), limit(1), offset(nil)
  3 - output([T_FUN_SUM(t2.a)]), filter([(T_OP_EXISTS, subquery(1))]), 
      exec_params_([T_FUN_SUM(t2.a)]), onetime_exprs_(nil), init_plan_idxs_(nil)
  4 - output([T_FUN_SUM(t2.a)]), filter(nil), 
      group([t2.a]), agg_func([T_FUN_SUM(t2.a)])
  5 - output([t2.a]), filter(nil), 
      access([t2.a]), partitions(p0)
  6 - output([t3.a], [t3.b]), filter([cast(t3.a, DECIMAL(11, 0)) > ?]), 
      access([t3.a], [t3.b]), partitions(p0)

explain basic select * from t1 where b > exists(select b from t2 where b > exists(select b from t3));
Query Plan
==========================
|ID|OPERATOR        |NAME|
--------------------------
|0 |SUBPLAN FILTER  |    |
|1 | TABLE SCAN     |t1  |
|2 | LIMIT          |    |
|3 |  SUBPLAN FILTER|    |
|4 |   TABLE SCAN   |t2  |
|5 |   TABLE SCAN   |t3  |
==========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.b], [t1.a]), filter([t1.b > ?]), 
      access([t1.b], [t1.a]), partitions(p0)
  2 - output([1]), filter(nil), limit(1), offset(nil)
  3 - output([1]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  4 - output([1]), filter([t2.b > ?]), 
      access([t2.b]), partitions(p0)
  5 - output([1]), filter(nil), 
      access([t3.__pk_increment]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1 where b > exists(select a from t2 where b > exists(select sum(a) from t3));
Query Plan
========================
|ID|OPERATOR      |NAME|
------------------------
|0 |SUBPLAN FILTER|    |
|1 | TABLE SCAN   |t1  |
|2 | TABLE SCAN   |t2  |
========================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter(nil), 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([t1.b], [t1.a]), filter([t1.b > ?]), 
      access([t1.b], [t1.a]), partitions(p0)
  2 - output([1]), filter([t2.b > 1]), 
      access([t2.b]), partitions(p0), 
      limit(1), offset(nil)

explain basic select * from t1 where b > exists(select sum(a) from t2 where t2.b > exists(select sum(a) from t3));
Query Plan
====================
|ID|OPERATOR  |NAME|
--------------------
|0 |TABLE SCAN|t1  |
====================

Outputs & filters: 
-------------------------------------
  0 - output([t1.a], [t1.b]), filter([t1.b > 1]), 
      access([t1.b], [t1.a]), partitions(p0)

drop table if exists T;
create table T (pk int);
explain basic select pk from t table1 where (table1.pk >= (select 1 from T limit 1)) AND ((1,9) in (select 1,9));
Query Plan
===========================
|ID|OPERATOR       |NAME  |
---------------------------
|0 |SUBPLAN FILTER |      |
|1 | SUBPLAN FILTER|      |
|2 |  TABLE SCAN   |table1|
|3 |  TABLE SCAN   |t     |
|4 | EXPRESSION    |      |
===========================

Outputs & filters: 
-------------------------------------
  0 - output([table1.pk]), filter([?]), 
      exec_params_(nil), onetime_exprs_([(1, 9) = ANY(subquery(1))]), init_plan_idxs_(nil)
  1 - output([table1.pk]), filter(nil), 
      exec_params_(nil), onetime_exprs_([subquery(1)]), init_plan_idxs_(nil)
  2 - output([table1.pk]), filter([table1.pk >= ?]), 
      access([table1.pk]), partitions(p0)
  3 - output([1]), filter(nil), 
      access([t.__pk_increment]), partitions(p0), 
      limit(1), offset(nil)
  4 - output([1], [9]), filter(nil)
      values({1, 9})

explain basic select (select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk)
from t;
Query Plan
================================
|ID|OPERATOR              |NAME|
--------------------------------
|0 |SUBPLAN FILTER        |    |
|1 | TABLE SCAN           |t   |
|2 | MERGE EXCEPT DISTINCT|    |
|3 |  EXPRESSION          |    |
|4 |  EXPRESSION          |    |
|5 | MERGE EXCEPT DISTINCT|    |
|6 |  EXPRESSION          |    |
|7 |  EXPRESSION          |    |
|8 | MERGE EXCEPT DISTINCT|    |
|9 |  EXPRESSION          |    |
|10|  EXPRESSION          |    |
|11| MERGE EXCEPT DISTINCT|    |
|12|  EXPRESSION          |    |
|13|  EXPRESSION          |    |
|14| MERGE EXCEPT DISTINCT|    |
|15|  EXPRESSION          |    |
|16|  EXPRESSION          |    |
|17| MERGE EXCEPT DISTINCT|    |
|18|  EXPRESSION          |    |
|19|  EXPRESSION          |    |
|20| MERGE EXCEPT DISTINCT|    |
|21|  EXPRESSION          |    |
|22|  EXPRESSION          |    |
|23| MERGE EXCEPT DISTINCT|    |
|24|  EXPRESSION          |    |
|25|  EXPRESSION          |    |
|26| MERGE EXCEPT DISTINCT|    |
|27|  EXPRESSION          |    |
|28|  EXPRESSION          |    |
|29| MERGE EXCEPT DISTINCT|    |
|30|  EXPRESSION          |    |
|31|  EXPRESSION          |    |
|32| MERGE EXCEPT DISTINCT|    |
|33|  EXPRESSION          |    |
|34|  EXPRESSION          |    |
|35| MERGE EXCEPT DISTINCT|    |
|36|  EXPRESSION          |    |
|37|  EXPRESSION          |    |
|38| MERGE EXCEPT DISTINCT|    |
|39|  EXPRESSION          |    |
|40|  EXPRESSION          |    |
|41| MERGE EXCEPT DISTINCT|    |
|42|  EXPRESSION          |    |
|43|  EXPRESSION          |    |
|44| MERGE EXCEPT DISTINCT|    |
|45|  EXPRESSION          |    |
|46|  EXPRESSION          |    |
|47| MERGE EXCEPT DISTINCT|    |
|48|  EXPRESSION          |    |
|49|  EXPRESSION          |    |
|50| MERGE EXCEPT DISTINCT|    |
|51|  EXPRESSION          |    |
|52|  EXPRESSION          |    |
|53| MERGE EXCEPT DISTINCT|    |
|54|  EXPRESSION          |    |
|55|  EXPRESSION          |    |
|56| MERGE EXCEPT DISTINCT|    |
|57|  EXPRESSION          |    |
|58|  EXPRESSION          |    |
|59| MERGE EXCEPT DISTINCT|    |
|60|  EXPRESSION          |    |
|61|  EXPRESSION          |    |
|62| MERGE EXCEPT DISTINCT|    |
|63|  EXPRESSION          |    |
|64|  EXPRESSION          |    |
|65| MERGE EXCEPT DISTINCT|    |
|66|  EXPRESSION          |    |
|67|  EXPRESSION          |    |
|68| MERGE EXCEPT DISTINCT|    |
|69|  EXPRESSION          |    |
|70|  EXPRESSION          |    |
|71| MERGE EXCEPT DISTINCT|    |
|72|  EXPRESSION          |    |
|73|  EXPRESSION          |    |
|74| MERGE EXCEPT DISTINCT|    |
|75|  EXPRESSION          |    |
|76|  EXPRESSION          |    |
|77| MERGE EXCEPT DISTINCT|    |
|78|  EXPRESSION          |    |
|79|  EXPRESSION          |    |
|80| MERGE EXCEPT DISTINCT|    |
|81|  EXPRESSION          |    |
|82|  EXPRESSION          |    |
|83| MERGE EXCEPT DISTINCT|    |
|84|  EXPRESSION          |    |
|85|  EXPRESSION          |    |
================================

Outputs & filters: 
-------------------------------------
  0 - output([subquery(1)], [subquery(2)], [subquery(3)], [subquery(4)], [subquery(5)], [subquery(6)], [subquery(7)], [subquery(8)], [subquery(9)], [subquery(10)], [subquery(11)], [subquery(12)], [subquery(13)], [subquery(14)], [subquery(15)], [subquery(16)], [subquery(17)], [subquery(18)], [subquery(19)], [subquery(20)], [subquery(21)], [subquery(22)], [subquery(23)], [subquery(24)], [subquery(25)], [subquery(26)], [subquery(27)], [subquery(28)]), filter(nil), 
      exec_params_([cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))], [cast(t.pk, BIGINT(20, 0))]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([t.pk]), filter(nil), 
      access([t.pk]), partitions(p0)
  2 - output([EXCEPT([1])]), filter(nil)
  3 - output([1]), filter(nil)
      values({1})
  4 - output([?]), filter(nil)
      values({?})
  5 - output([EXCEPT([1])]), filter(nil)
  6 - output([1]), filter(nil)
      values({1})
  7 - output([?]), filter(nil)
      values({?})
  8 - output([EXCEPT([1])]), filter(nil)
  9 - output([1]), filter(nil)
      values({1})
  10 - output([?]), filter(nil)
      values({?})
  11 - output([EXCEPT([1])]), filter(nil)
  12 - output([1]), filter(nil)
      values({1})
  13 - output([?]), filter(nil)
      values({?})
  14 - output([EXCEPT([1])]), filter(nil)
  15 - output([1]), filter(nil)
      values({1})
  16 - output([?]), filter(nil)
      values({?})
  17 - output([EXCEPT([1])]), filter(nil)
  18 - output([1]), filter(nil)
      values({1})
  19 - output([?]), filter(nil)
      values({?})
  20 - output([EXCEPT([1])]), filter(nil)
  21 - output([1]), filter(nil)
      values({1})
  22 - output([?]), filter(nil)
      values({?})
  23 - output([EXCEPT([1])]), filter(nil)
  24 - output([1]), filter(nil)
      values({1})
  25 - output([?]), filter(nil)
      values({?})
  26 - output([EXCEPT([1])]), filter(nil)
  27 - output([1]), filter(nil)
      values({1})
  28 - output([?]), filter(nil)
      values({?})
  29 - output([EXCEPT([1])]), filter(nil)
  30 - output([1]), filter(nil)
      values({1})
  31 - output([?]), filter(nil)
      values({?})
  32 - output([EXCEPT([1])]), filter(nil)
  33 - output([1]), filter(nil)
      values({1})
  34 - output([?]), filter(nil)
      values({?})
  35 - output([EXCEPT([1])]), filter(nil)
  36 - output([1]), filter(nil)
      values({1})
  37 - output([?]), filter(nil)
      values({?})
  38 - output([EXCEPT([1])]), filter(nil)
  39 - output([1]), filter(nil)
      values({1})
  40 - output([?]), filter(nil)
      values({?})
  41 - output([EXCEPT([1])]), filter(nil)
  42 - output([1]), filter(nil)
      values({1})
  43 - output([?]), filter(nil)
      values({?})
  44 - output([EXCEPT([1])]), filter(nil)
  45 - output([1]), filter(nil)
      values({1})
  46 - output([?]), filter(nil)
      values({?})
  47 - output([EXCEPT([1])]), filter(nil)
  48 - output([1]), filter(nil)
      values({1})
  49 - output([?]), filter(nil)
      values({?})
  50 - output([EXCEPT([1])]), filter(nil)
  51 - output([1]), filter(nil)
      values({1})
  52 - output([?]), filter(nil)
      values({?})
  53 - output([EXCEPT([1])]), filter(nil)
  54 - output([1]), filter(nil)
      values({1})
  55 - output([?]), filter(nil)
      values({?})
  56 - output([EXCEPT([1])]), filter(nil)
  57 - output([1]), filter(nil)
      values({1})
  58 - output([?]), filter(nil)
      values({?})
  59 - output([EXCEPT([1])]), filter(nil)
  60 - output([1]), filter(nil)
      values({1})
  61 - output([?]), filter(nil)
      values({?})
  62 - output([EXCEPT([1])]), filter(nil)
  63 - output([1]), filter(nil)
      values({1})
  64 - output([?]), filter(nil)
      values({?})
  65 - output([EXCEPT([1])]), filter(nil)
  66 - output([1]), filter(nil)
      values({1})
  67 - output([?]), filter(nil)
      values({?})
  68 - output([EXCEPT([1])]), filter(nil)
  69 - output([1]), filter(nil)
      values({1})
  70 - output([?]), filter(nil)
      values({?})
  71 - output([EXCEPT([1])]), filter(nil)
  72 - output([1]), filter(nil)
      values({1})
  73 - output([?]), filter(nil)
      values({?})
  74 - output([EXCEPT([1])]), filter(nil)
  75 - output([1]), filter(nil)
      values({1})
  76 - output([?]), filter(nil)
      values({?})
  77 - output([EXCEPT([1])]), filter(nil)
  78 - output([1]), filter(nil)
      values({1})
  79 - output([?]), filter(nil)
      values({?})
  80 - output([EXCEPT([1])]), filter(nil)
  81 - output([1]), filter(nil)
      values({1})
  82 - output([?]), filter(nil)
      values({?})
  83 - output([EXCEPT([1])]), filter(nil)
  84 - output([1]), filter(nil)
      values({1})
  85 - output([?]), filter(nil)
      values({?})

select (select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk),
(select 1 except select pk)
from t;
(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)	(select 1 except select pk)
drop table if exists t1,t2,t3;

CREATE TABLE `t1` (
`c1` varbinary(20) DEFAULT NULL
) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 2 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0;
CREATE TABLE `t2` (
`a` int(11) NOT NULL,
`b` varchar(20) DEFAULT NULL,
`c` decimal(20,10) DEFAULT NULL,
PRIMARY KEY (`a`)
) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 2 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0
partition by hash(a) partitions 2;
insert into t1 values(1), (2);
insert into t2 values(1,2,1);
select /*+no_rewrite*/(select sum(b) from t2) as temp from t1 group by temp having temp > 4 and temp > (select sum(b) from t2);
temp
drop table t1;
drop table t2;

CREATE TABLE `t1` (
`pk1` int(11) NOT NULL,
`pk2` varchar(10) NOT NULL,
`c1` int(11) DEFAULT NULL,
`c2` int(11) DEFAULT NULL,
`c3` varchar(20) DEFAULT NULL,
`c4` timestamp(6) NULL DEFAULT '2012-01-01 04:00:00.000000',
`c5` int(11) DEFAULT NULL,
PRIMARY KEY (`pk1`, `pk2`)
) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 2 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0;
insert into t1 values(1, '2', 3, 3, null, null, null);
select /*+no_rewrite*/ c1, (select max(c2) FROM t1 ) a FROM t1  order by (select c1 FROM t1  where c2 in (select c1 FROM t1  where c2 = a)) + 1;
c1	a
3	3
drop table t1;
