drop table if exists t0, t1, t2, t3, t4, t10, t11, t12, t, v, it1, it2, it3, ot1, ot2, ot3;
drop view if exists v1, v2, v3;
#
# BUG#41842: Semi-join materialization strategy crashes when the upper query has HAVING
#
CREATE TABLE t1 (
pk int(11) NOT NULL AUTO_INCREMENT,
int_nokey int(11) NOT NULL,
time_key time NOT NULL,
datetime_key datetime NOT NULL,
datetime_nokey datetime NOT NULL,
varchar_key varchar(1) NOT NULL,
varchar_nokey varchar(1) NOT NULL,
PRIMARY KEY (pk),
KEY time_key (time_key),
KEY datetime_key (datetime_key),
KEY varchar_key (varchar_key)
);
INSERT INTO t1 VALUES 
(1,0, '00:16:10','2008-09-03 14:25:40','2008-09-03 14:25:40','h','h'),
(2,7, '00:00:00','2001-01-13 00:00:00','2001-01-13 00:00:00','',''),
(3,0, '00:00:00','0000-00-00 00:00:00','0000-00-00 00:00:00','x','x'),
(4,2, '16:29:24','2000-10-16 01:39:08','2000-10-16 01:39:08','w','w'),
(5,1, '09:23:32','0000-00-00 00:00:00','0000-00-00 00:00:00','p','p'),
(6,3, '00:00:00','2007-12-02 00:00:00','2007-12-02 00:00:00','o','o'),
(7,3, '00:00:00','2008-09-11 00:00:00','2008-09-11 00:00:00','',''),
(8,0, '13:59:04','0000-00-00 00:00:00','0000-00-00 00:00:00','s','s'),
(9,7, '09:01:06','0000-00-00 00:00:00','0000-00-00 00:00:00','d','d'),
(10,5,'00:00:00','0000-00-00 00:00:00','0000-00-00 00:00:00','n','n'),
(11,0,'21:06:46','0000-00-00 00:00:00','0000-00-00 00:00:00','o','o'),
(12,2,'00:00:00','0000-00-00 00:00:00','0000-00-00 00:00:00','',''),
(13,6,'14:45:34','2003-07-28 02:34:08','2003-07-28 02:34:08','w','w'),
(14,1,'15:04:12','0000-00-00 00:00:00','0000-00-00 00:00:00','o','o'),
(15,0,'00:00:00','0000-00-00 00:00:00','0000-00-00 00:00:00','x','x'),
(16,0,'15:55:23','2004-03-17 00:32:27','2004-03-17 00:32:27','p','p'),
(17,1,'16:30:00','2004-12-27 19:20:00','2004-12-27 19:20:00','d','d'),
(18,0,'00:00:00','0000-00-00 00:00:00','0000-00-00 00:00:00','h','h'),
(19,0,'14:13:26','2008-11-09 05:53:48','2008-11-09 05:53:48','o','o'),
(20,0,'00:00:00','2009-10-11 06:58:04','2009-10-11 06:58:04','k','k');
CREATE TABLE t2 (
pk int(11) NOT NULL AUTO_INCREMENT,
int_nokey int(11) NOT NULL,
time_key time NOT NULL,
datetime_key datetime NOT NULL,
datetime_nokey datetime NOT NULL,
varchar_key varchar(1) NOT NULL,
varchar_nokey varchar(1) NOT NULL,
PRIMARY KEY (pk),
KEY time_key (time_key),
KEY datetime_key (datetime_key),
KEY varchar_key (varchar_key)
);
INSERT INTO t2 VALUES 
(10,0,'19:39:13','0000-00-00 00:00:00','0000-00-00 00:00:00','g','g'),
(11,8,'03:43:53','0000-00-00 00:00:00','0000-00-00 00:00:00','b','b');
SELECT OUTR.datetime_nokey AS X FROM t1 AS OUTR 
WHERE 
OUTR.varchar_nokey IN (SELECT 
INNR . varchar_nokey AS Y 
FROM t2 AS INNR 
WHERE
INNR . datetime_key >= INNR . time_key OR 
INNR . pk = INNR . int_nokey  
) 
AND OUTR . varchar_nokey <= 'w' 
HAVING X > '2012-12-12';
X
drop table t1, t2;

Bug#46797 "Crash in fix_semijoin_strategies_for_picked_join_order 
with semijoin=on"

CREATE TABLE t1 (
varchar_key varchar(1) DEFAULT NULL,
KEY varchar_key (varchar_key)
);
CREATE TABLE t2 (
varchar_key varchar(1) DEFAULT NULL,
KEY varchar_key (varchar_key)
);
INSERT INTO t2 VALUES
(NULL),(NULL),(NULL),(NULL),('a'),('a'),('a'),('b'),('b'),('b'),('b'),('c'),
('c'),('c'),('c'),('c'),('c'),('c'),('d'),('d'),('d'),('d'),('d'),('d'),('e'),
('e'),('e'),('e'),('e'),('e'),('f'),('f'),('f'),('g'),('g'),('h'),('h'),('h'),
('h'),('i'),('j'),('j'),('j'),('k'),('k'),('l'),('l'),('m'),('m'),('m'),('m'),
('n'),('n'),('n'),('o'),('o'),('o'),('p'),('p'),('p'),('q'),('q'),('q'),('r'),
('r'),('r'),('r'),('s'),('s'),('s'),('s'),('t'),('t'),('t'),('t'),('u'),('u'),
('u'),('u'),('v'),('v'),('v'),('v'),('w'),('w'),('w'),('w'),('w'),('w'),('x'),
('x'),('x'),('y'),('y'),('y'),('y'),('z'),('z'),('z'),('z');
CREATE TABLE t3 (
varchar_key varchar(1) DEFAULT NULL,
KEY varchar_key (varchar_key)
) ;
INSERT INTO t3 VALUES
(NULL),('c'),('d'),('e'),('f'),('h'),('j'),('k'),('k'),('m'),('m'),('m'),
('n'),('o'),('r'),('t'),('t'),('u'),('w'),('y');
SELECT varchar_key FROM t3 
WHERE (SELECT varchar_key FROM t3 
WHERE (varchar_key,varchar_key) 
IN (SELECT t1.varchar_key, t2 .varchar_key 
FROM t1 RIGHT JOIN t2 ON t1.varchar_key  
)  
);
varchar_key
DROP TABLE t1, t2, t3;
#
# Bug#46556 Returning incorrect, empty results for some IN subqueries 
#           w/semijoin=on
#
CREATE TABLE t0 (
pk INTEGER,
vkey VARCHAR(1),
vnokey VARCHAR(1),
PRIMARY KEY (pk),
KEY vkey(vkey)
);
INSERT INTO t0 
VALUES (1,'g','g'), (2,'v','v'), (3,'t','t'), (4,'u','u'), (5,'n','n');
SELECT vkey FROM t0 WHERE pk IN 
(SELECT t1.pk FROM t0 t1 JOIN t0 t2 ON t2.vkey = t1.vnokey);
vkey
g
v
t
u
n
DROP TABLE t0;
# End of bug#46556
#
# Bug#46692 "Crash occurring on queries with nested FROM subqueries 
# using materialization."
#
CREATE TABLE t1 (
pk INTEGER PRIMARY KEY,
int_key INTEGER,
KEY int_key(int_key)
);
INSERT INTO t1 VALUES (10,186),(11,NULL),(12,2),(13,3),(14,0),(15,133),(16,1);
CREATE TABLE t2 (
pk INTEGER PRIMARY KEY,
int_key INTEGER,
KEY int_key(int_key)
);
INSERT INTO t2 VALUES (1,7),(2,2);
SELECT * FROM t1 WHERE (140, 4) IN 
(SELECT t2.int_key, t2 .pk FROM t2 JOIN t1 ON t2.int_key);
pk	int_key
DROP TABLE t1, t2;
#
# Bug#42353 "SELECT ... WHERE oe IN (SELECT w/ LEFT JOIN) query
# causes crash."
#
CREATE TABLE t1 (
pk INTEGER PRIMARY KEY,
int_nokey INTEGER,
int_key INTEGER,
date_key DATE,
datetime_nokey DATETIME,
varchar_nokey VARCHAR(1)
);
CREATE TABLE t2 (
date_nokey DATE
);
CREATE TABLE t3 (
pk INTEGER PRIMARY KEY,
int_nokey INTEGER,
date_key date,
varchar_key VARCHAR(1),
varchar_nokey VARCHAR(1),
KEY date_key (date_key)
);
SELECT date_key FROM t1
WHERE (int_key, int_nokey)
IN (SELECT  t3.int_nokey, t3.pk
FROM t2 LEFT JOIN t3 ON (t2.date_nokey < t3.date_key) 
WHERE t3.varchar_key <= t3.varchar_nokey OR t3.int_nokey <= t3.pk
)
AND (varchar_nokey <> 'f' OR NOT int_key < 7);
date_key
#
# Bug#45933 "Crash in optimize_semijoin_nests on JOIN in subquery 
# + AND in outer query".
#
INSERT INTO t1 VALUES (10,7,5,'2009-06-16','2002-04-10 14:25:30','w'),
(11,7,0,'0000-00-00','0000-00-00 00:00:00','s'), 
(12,4,0,'2003-07-14','2006-09-14 04:01:02','y'), 
(13,0,4,'2002-07-25','0000-00-00 00:00:00','c'), 
(14,1,8,'2007-07-03','0000-00-00 00:00:00','q'), 
(15,6,5,'2001-11-12','0000-00-00 00:00:00',''), 
(16,2,9,'0000-00-00','0000-00-00 00:00:00','j'), 
(29,9,1,'0000-00-00','2003-08-11 00:00:00','m');
INSERT INTO t3 VALUES (1,9,'0000-00-00','b','b'),
(2,2,'2002-09-17','h','h');
SELECT t1.varchar_nokey FROM t1 JOIN t3 ON t1.datetime_nokey
WHERE t1.varchar_nokey 
IN (SELECT varchar_nokey FROM t1 
WHERE (pk) 
IN (SELECT t3.int_nokey
FROM t3 LEFT JOIN t1 ON t1.varchar_nokey
WHERE t3.date_key BETWEEN '2008-06-07' AND '2006-06-26'
           )  
);
varchar_nokey
DROP TABLE t1, t2, t3;
#
# Bug#45219 "Crash on SELECT DISTINCT query containing a  
# LEFT JOIN in subquery"
#
CREATE TABLE t1 (
pk INTEGER NOT NULL,
int_nokey INTEGER NOT NULL,
datetime_key DATETIME NOT NULL,
varchar_key VARCHAR(1) NOT NULL,
PRIMARY KEY (pk),
KEY datetime_key (datetime_key),
KEY varchar_key (varchar_key)
);
INSERT INTO t1 VALUES
(1,9,'0000-00-00 00:00:00','p'),(2,0,'2002-02-09 07:38:13','v'),
(3,8,'2001-05-03 12:08:14','t'),(4,3,'0000-00-00 00:00:00','u'),
(5,7,'2009-07-28 03:43:30','n'),(6,0,'2009-08-04 00:00:00','l'),
(7,1,'0000-00-00 00:00:00','h'),(8,9,'0000-00-00 00:00:00','u'),
(9,0,'2005-08-02 17:16:54','n'),(10,9,'2002-12-21 00:00:00','j'),
(11,0,'2005-08-15 12:37:35','k'),(12,5,'0000-00-00 00:00:00','e'),
(13,0,'2006-03-10 00:00:00','i'),(14,8,'2005-05-16 11:02:36','u'),
(15,8,'2008-11-02 00:00:00','n'),(16,5,'2006-03-15 00:00:00','b'),
(17,1,'0000-00-00 00:00:00','x'),(18,7,'0000-00-00 00:00:00',''),
(19,0,'2008-12-17 20:15:40','q'),(20,9,'0000-00-00 00:00:00','u');
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES 
(10,0,'2006-07-07 07:26:28','q'),(11,5,'2002-09-23 00:00:00','m'),
(12,7,'0000-00-00 00:00:00','j'),(13,1,'2006-06-07 00:00:00','z'),
(14,8,'2000-09-16 12:15:34','a'),(15,2,'2007-08-05 15:47:52',''),
(16,1,'0000-00-00 00:00:00','e'),(17,8,'2005-12-02 19:34:26','t'),
(18,5,'0000-00-00 00:00:00','q'),(19,4,'0000-00-00 00:00:00','b'),
(20,5,'2007-12-28 00:00:00','w'),(21,3,'2004-08-02 11:48:43','m'),
(22,0,'0000-00-00 00:00:00','x'),(23,8,'2004-04-19 12:18:43',''),
(24,0,'2009-04-27 00:00:00','w'),(25,4,'2006-10-20 14:52:15','x'),
(26,0,'0000-00-00 00:00:00','e'),(27,0,'2002-03-22 11:48:37','e'),
(28,2,'0000-00-00 00:00:00','p'),(29,0,'2001-01-04 03:55:07','x');
CREATE TABLE t3 LIKE t1;
INSERT INTO t3 VALUES
(10,8,'2007-08-19 08:08:38','i'),(11,0,'2000-05-21 03:51:51','');
SELECT DISTINCT datetime_key FROM t1
WHERE (int_nokey, pk)  
IN (SELECT t3.pk, t3.pk FROM t2 LEFT JOIN t3 ON t3.varchar_key)  
AND pk = 9;
datetime_key
DROP TABLE t1, t2, t3;
#
# Bug#46550 Azalea returning duplicate results for some IN subqueries
# w/ semijoin=on
#
DROP TABLE IF EXISTS t0, t1, t2;
CREATE TABLE t0 (
int_key int(11) DEFAULT NULL,
varchar_key varchar(1) DEFAULT NULL,
varchar_nokey varchar(1) DEFAULT NULL,
KEY int_key (int_key),
KEY varchar_key (varchar_key,int_key)
);
INSERT INTO t0 VALUES
(1,'m','m'),
(40,'h','h'),
(1,'r','r'),
(1,'h','h'),
(9,'x','x'),
(NULL,'q','q'),
(NULL,'k','k'),
(7,'l','l'),
(182,'k','k'),
(202,'a','a'),
(7,'x','x'),
(6,'j','j'),
(119,'z','z'),
(4,'d','d'),
(5,'h','h'),
(1,'u','u'),
(3,'q','q'),
(7,'a','a'),
(3,'e','e'),
(6,'l','l');
CREATE TABLE t1 (
int_key int(11) DEFAULT NULL,
varchar_key varchar(1) DEFAULT NULL,
varchar_nokey varchar(1) DEFAULT NULL,
KEY int_key (int_key),
KEY varchar_key (varchar_key,int_key)
);
INSERT INTO t1 VALUES (7,NULL,NULL),(4,'x','x');
CREATE TABLE t2 (
int_key int(11) DEFAULT NULL,
varchar_key varchar(1) DEFAULT NULL,
varchar_nokey varchar(1) DEFAULT NULL,
KEY int_key (int_key),
KEY varchar_key (varchar_key,int_key)
);
INSERT INTO t2 VALUES (123,NULL,NULL);
SELECT int_key  
FROM t0  
WHERE varchar_nokey  IN (  
SELECT t1 .varchar_key  from t1
);
int_key
9
7
SELECT t0.int_key  
FROM t0
WHERE t0.varchar_nokey  IN (  
SELECT t1_1 .varchar_key  
FROM t1 AS t1_1  JOIN t1 AS t1_2 ON t1_1 .int_key
);
int_key
9
7
SELECT t0.int_key  
FROM t0, t2
WHERE t0.varchar_nokey  IN (  
SELECT t1_1 .varchar_key  
FROM t1 AS t1_1  JOIN t1 AS t1_2 ON t1_1 .int_key  
);
int_key
9
7
DROP TABLE t0, t1, t2;
# End of bug#46550

Bug #48073 Subquery on char columns from view crashes Mysql

DROP TABLE IF EXISTS t1, t2;
DROP VIEW IF EXISTS v1;
CREATE TABLE t1 (
city VARCHAR(50) NOT NULL,
country_id SMALLINT UNSIGNED NOT NULL
);
INSERT INTO t1 VALUES 
('Batna',2),
('Bchar',2),
('Skikda',2),
('Tafuna',3),
('Algeria',2) ;
CREATE TABLE t2 (
country_id SMALLINT UNSIGNED NOT NULL,
country VARCHAR(50) NOT NULL
);
INSERT INTO t2 VALUES
(2,'Algeria'),
(3,'American Samoa') ;
drop table t1, t2;
# End of bug#48073

Bug#49097 subquery with view generates wrong result with
non-prepared statement

DROP TABLE IF EXISTS t1, t2;
DROP VIEW IF EXISTS v1;
CREATE TABLE t1 (
city VARCHAR(50) NOT NULL,
country_id SMALLINT UNSIGNED NOT NULL
);
INSERT INTO t1 VALUES 
('Batna',2),
('Bchar',2),
('Skikda',2),
('Tafuna',3),
('Algeria',2) ;
CREATE TABLE t2 (
country_id SMALLINT UNSIGNED NOT NULL,
country VARCHAR(50) NOT NULL
);
INSERT INTO t2 VALUES
(2,'Algeria'),
(3,'XAmerican Samoa') ;
drop table t1, t2;
# End of Bug#49097
# 
# Bug#49198 Wrong result for second call of procedure
#           with view in subselect.
# 
CREATE TABLE t1 (t1field integer, primary key (t1field));
CREATE TABLE t2 (t2field integer, primary key (t2field));
CREATE TABLE t3 (t3field integer, primary key (t3field));
CREATE VIEW v2 AS SELECT * FROM t2;
CREATE VIEW v3 AS SELECT * FROM t3;
INSERT INTO t1 VALUES(1),(2);
INSERT INTO t2 VALUES(1),(2);
INSERT INTO t3 VALUES(1),(2);
DROP TABLE t1, t2, t3;
DROP VIEW v2, v3;
# End of Bug#49198
# 
# Bug#48623 Multiple subqueries are optimized incorrectly
# 
CREATE TABLE ot(val VARCHAR(10));
CREATE TABLE it1(val VARCHAR(10));
CREATE TABLE it2(val VARCHAR(10));
INSERT INTO ot  VALUES('aaa'), ('bbb'), ('eee'), ('mmm'), ('ppp');
INSERT INTO it1 VALUES('aaa'), ('aaa'), ('bbb'), ('eee'), ('mmm'), ('ppp');
INSERT INTO it2 VALUES('aaa'), ('bbb'), ('eee'), ('mmm'), ('ppp');
SELECT *
FROM ot
WHERE ot.val IN (SELECT it1.val FROM it1
WHERE  it1.val LIKE 'a%' OR it1.val LIKE 'e%')
AND ot.val IN (SELECT it2.val FROM it2
WHERE  it2.val LIKE 'a%' OR it2.val LIKE 'e%');
val
aaa
eee
DROP TABLE ot;
DROP TABLE it1;
DROP TABLE it2;
# End of Bug#48623
# 
# Bug #51487 Assertion failure when semi-join flattening occurs
#            for a subquery in HAVING 
# 
CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 VALUES (1,10),(2,11),(1,13);
CREATE TABLE t2 like t1;
INSERT INTO t2 SELECT * FROM t1;
CREATE TABLE t3 like t1;
INSERT INTO t3 SELECT * FROM t1;
SELECT COUNT(*) FROM t1
GROUP BY t1.a 
HAVING t1.a IN (SELECT t3.a FROM t3
WHERE t3.b IN (SELECT b FROM t2 WHERE t2.a=t1.a));
COUNT(*)
2
1
DROP TABLE t1, t2, t3;
# End of Bug#51487
# 
# BUG#38075: Wrong result: rows matching a subquery with outer join not returned
# 
DROP TABLE IF EXISTS ot1, it1, it2;
CREATE TABLE it2 (
int_key int(11) NOT NULL,
datetime_key datetime NOT NULL,
KEY int_key (int_key),
KEY datetime_key (datetime_key)
);
INSERT INTO it2 VALUES
(5,'2002-04-10 14:25:30'), (0,'0000-00-00 00:00:00'),
(0,'2006-09-14 04:01:02'), (4,'0000-00-00 00:00:00'),
(8,'0000-00-00 00:00:00'), (5,'0000-00-00 00:00:00'),
(9,'0000-00-00 00:00:00'), (8,'2007-04-01 11:04:17'),
(1,'0000-00-00 00:00:00'), (7,'2009-01-12 00:00:00'),
(0,'2009-06-05 00:00:00'), (3,'2006-02-14 18:06:35'),
(5,'2006-02-21 07:08:16'), (0,'0000-00-00 00:00:00'),
(7,'0000-00-00 00:00:00'), (0,'0000-00-00 00:00:00'),
(0,'2007-02-13 00:00:00'), (1,'0000-00-00 00:00:00'),
(0,'0000-00-00 00:00:00'), (1,'2003-08-11 00:00:00');
CREATE TABLE ot1 (
int_nokey int(11) NOT NULL,
int_key int(11) NOT NULL,
KEY int_key (int_key)
);
INSERT INTO ot1 VALUES
(5,0), (3,0), (0,2), (3,0), (1,3), (0,0), (1,7), (7,0), (1,7), (0,7),
(0,9), (8,2), (4,4), (9,3), (0,9), (2,5), (0,5), (8,0), (5,8), (1,5);
CREATE TABLE it1 (
int_nokey int(11) NOT NULL,
int_key int(11) NOT NULL,
KEY int_key (int_key)
);
INSERT INTO it1 VALUES
(9,5), (0,4);
SELECT int_key FROM ot1
WHERE int_nokey IN (SELECT it2.int_key
FROM it1 LEFT JOIN it2 ON it2.datetime_key);
int_key
0
0
0
0
0
0
2
2
3
5
5
7
7
7
8
9
9
DROP TABLE ot1, it1, it2;
# End of BUG#38075
# 
# BUG#50089: Second call of procedure with view in subselect crashes server
# 
CREATE TABLE t1(t1field INTEGER, PRIMARY KEY(t1field));
CREATE VIEW v1 AS 
SELECT t1field AS v1field
FROM t1 a
WHERE a.t1field IN (SELECT t1field FROM t1);
INSERT INTO t1 VALUES(1),(2);
SELECT t1field
FROM t1
WHERE t1field IN (SELECT v1field FROM v1);
t1field
1
2
SELECT t1.t1field
FROM t1 LEFT JOIN t1 AS t2 ON TRUE WHERE t1.t1field IN (SELECT v1field FROM v1);
t1field
1
1
2
2
DROP VIEW v1;
DROP TABLE t1;
# End of BUG#50089
#
# Bug#45191: Incorrectly initialized semi-join led to a wrong result.
#
CREATE TABLE STAFF (EMPNUM   CHAR(3) NOT NULL,
EMPNAME  CHAR(20), GRADE DECIMAL(4), CITY CHAR(15));
CREATE TABLE PROJ (PNUM CHAR(3) NOT NULL,
PNAME    CHAR(20), PTYPE CHAR(6),
BUDGET   DECIMAL(9),
CITY     CHAR(15));
CREATE TABLE WORKS (EMPNUM CHAR(3) NOT NULL,
PNUM CHAR(3) NOT NULL, HOURS DECIMAL(5));
INSERT INTO STAFF VALUES ('E1','Alice',12,'Deale');
INSERT INTO STAFF VALUES ('E2','Betty',10,'Vienna');
INSERT INTO STAFF VALUES ('E3','Carmen',13,'Vienna');
INSERT INTO STAFF VALUES ('E4','Don',12,'Deale');
INSERT INTO STAFF VALUES ('E5','Ed',13,'Akron');
INSERT INTO PROJ VALUES  ('P1','MXSS','Design',10000,'Deale');
INSERT INTO PROJ VALUES  ('P2','CALM','Code',30000,'Vienna');
INSERT INTO PROJ VALUES  ('P3','SDP','Test',30000,'Tampa');
INSERT INTO PROJ VALUES  ('P4','SDP','Design',20000,'Deale');
INSERT INTO PROJ VALUES  ('P5','IRM','Test',10000,'Vienna');
INSERT INTO PROJ VALUES  ('P6','PAYR','Design',50000,'Deale');
INSERT INTO WORKS VALUES  ('E1','P1',40);
INSERT INTO WORKS VALUES  ('E1','P2',20);
INSERT INTO WORKS VALUES  ('E1','P3',80);
INSERT INTO WORKS VALUES  ('E1','P4',20);
INSERT INTO WORKS VALUES  ('E1','P5',12);
INSERT INTO WORKS VALUES  ('E1','P6',12);
INSERT INTO WORKS VALUES  ('E2','P1',40);
INSERT INTO WORKS VALUES  ('E2','P2',80);
INSERT INTO WORKS VALUES  ('E3','P2',20);
INSERT INTO WORKS VALUES  ('E4','P2',20);
INSERT INTO WORKS VALUES  ('E4','P4',40);
INSERT INTO WORKS VALUES  ('E4','P5',80);
SELECT EMPNUM, EMPNAME
FROM STAFF
WHERE EMPNUM IN
(SELECT EMPNUM  FROM WORKS
WHERE PNUM IN
(SELECT PNUM  FROM PROJ));
EMPNUM	EMPNAME
E1	Alice
E2	Betty
E3	Carmen
E4	Don
drop table STAFF,WORKS,PROJ;
# End of bug#45191
#  
# BUG#36896: Server crash on SELECT FROM DUAL
# 
create table t1 (a int);
select 1 as res from dual where (1) in (select * from t1);
res
drop table t1;

BUG#40118 Crash when running Batched Key Access and requiring one match for each key

create table t0(a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (a int, key(a));
insert into t1 select * from t0;
alter table t1 add b int not null, add filler char(200);
insert into t1 select * from t1;
insert into t1 select * from t1;
select * from t0 where t0.a in (select t1.a from t1 where t1.b=0);
a
0
1
2
3
4
5
6
7
8
9
drop table t0, t1;
# 
# BUG#32665 Query with dependent subquery is too slow
#
create table t1 (
idIndividual int primary key
);
insert into t1 values (1),(2);
create table t2 (
idContact int primary key,
contactType int,
idObj int
);
insert into t2 values (1,1,1),(2,2,2),(3,3,3);
create table t3 (
idAddress int primary key,
idContact int,
postalStripped varchar(100)
);
insert into t3 values (1,1, 'foo'), (2,2,'bar');
The following must be converted to a semi-join:
drop table t1,t2,t3;
CREATE TABLE t1 (one int, two int, flag char(1));
CREATE TABLE t2 (one int, two int, flag char(1));
INSERT INTO t1 VALUES(1,2,'Y'),(2,3,'Y'),(3,4,'Y'),(5,6,'N'),(7,8,'N');
INSERT INTO t2 VALUES(1,2,'Y'),(2,3,'Y'),(3,4,'Y'),(5,6,'N'),(7,8,'N');
SELECT * FROM t1
WHERE ROW(one,two) IN (SELECT DISTINCT one,two FROM t2 WHERE flag = 'N');
one	two	flag
5	6	N
7	8	N
SELECT * FROM t1
WHERE ROW(one,two) IN (SELECT DISTINCT one,two FROM t1 WHERE flag = 'N');
one	two	flag
5	6	N
7	8	N
insert into t2 values (null,null,'N');
insert into t2 values (null,3,'0');
insert into t2 values (null,5,'0');
insert into t2 values (10,null,'0');
insert into t1 values (10,3,'0');
insert into t1 values (10,5,'0');
insert into t1 values (10,10,'0');
SELECT one,two,ROW(one,two) IN (SELECT one,two FROM t2 WHERE flag = 'N') as 'test' from t1;
one	two	test
1	2	NULL
2	3	NULL
3	4	NULL
5	6	1
7	8	1
10	3	NULL
10	5	NULL
10	10	NULL
SELECT one,two from t1 where ROW(one,two) IN (SELECT one,two FROM t2 WHERE flag = 'N');
one	two
5	6
7	8
SELECT one,two,ROW(one,two) IN (SELECT one,two FROM t2 WHERE flag = 'N' group by one,two) as 'test' from t1;
one	two	test
1	2	NULL
2	3	NULL
3	4	NULL
5	6	1
7	8	1
10	3	NULL
10	5	NULL
10	10	NULL
SELECT one,two,ROW(one,two) IN (SELECT one,two FROM t2 WHERE flag = '0') as 'test' from t1;
one	two	test
1	2	0
2	3	NULL
3	4	0
5	6	0
7	8	0
10	3	NULL
10	5	NULL
10	10	NULL
SELECT one,two,ROW(one,two) IN (SELECT one,two FROM t2 WHERE flag = '0' group by one,two) as 'test' from t1;
one	two	test
1	2	0
2	3	NULL
3	4	0
5	6	0
7	8	0
10	3	NULL
10	5	NULL
10	10	NULL
DROP TABLE t1,t2;
CREATE TABLE t1 (a char(5), b char(5));
INSERT INTO t1 VALUES (NULL,'aaa'), ('aaa','aaa');
SELECT * FROM t1 WHERE (a,b) IN (('aaa','aaa'), ('aaa','bbb'));
a	b
aaa	aaa
DROP TABLE t1;
CREATE TABLE t1 (a CHAR(1), b VARCHAR(10));
INSERT INTO t1 VALUES ('a', 'aa');
INSERT INTO t1 VALUES ('a', 'aaa');
SELECT a,b FROM t1 WHERE b IN (SELECT a FROM t1);
a	b
CREATE INDEX I1 ON t1 (a);
CREATE INDEX I2 ON t1 (b);
SELECT a,b FROM t1 WHERE b IN (SELECT a FROM t1);
a	b
CREATE TABLE t2 (a VARCHAR(1), b VARCHAR(10));
INSERT INTO t2 SELECT * FROM t1;
CREATE INDEX I1 ON t2 (a);
CREATE INDEX I2 ON t2 (b);
SELECT a,b FROM t2 WHERE b IN (SELECT a FROM t2);
a	b
SELECT a,b FROM t1 WHERE b IN (SELECT a FROM t1 WHERE LENGTH(a)<500);
a	b
DROP TABLE t1,t2;
#
# BUG#45928 "Differing query results depending on MRR and
# engine_condition_pushdown settings"
#
CREATE TABLE `t1` (
`pk` int(11) NOT NULL AUTO_INCREMENT,
`time_nokey` time NOT NULL,
`varchar_key` varchar(1) NOT NULL,
`varchar_nokey` varchar(1) NOT NULL,
PRIMARY KEY (`pk`),
KEY `varchar_key` (`varchar_key`)
) AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;
INSERT INTO `t1` VALUES (10,'00:00:00','i','i'),(11,'00:00:00','','');
SELECT `time_nokey` G1  FROM t1  WHERE ( `varchar_nokey`  , `varchar_key`  )  IN ( 
SELECT `varchar_nokey`  , `varchar_nokey`  )  AND `varchar_key`  >= 'c' HAVING G1  ORDER 
BY `pk`   ;
G1
DROP TABLE t1;
#
# BUG#45863 "Assertion failed: (fixed == 0), function fix_fields(),
#            file item.cc, line 4448"
#
DROP TABLE IF EXISTS C, BB;
CREATE TABLE C (
varchar_nokey varchar(1) NOT NULL
);
INSERT INTO C VALUES
('k'),('a'),(''),('u'),('e'),('v'),('i'),
('t'),('u'),('f'),('u'),('m'),('j'),('f'),
('v'),('j'),('g'),('e'),('h'),('z');
CREATE TABLE BB (
varchar_nokey varchar(1) NOT NULL
);
INSERT INTO BB VALUES ('i'),('t');
SELECT varchar_nokey FROM C
WHERE (varchar_nokey, OUTR) IN (SELECT varchar_nokey
FROM BB);
ERROR 42S22: Unknown column 'OUTR' in 'where clause'
SELECT varchar_nokey FROM C
WHERE (varchar_nokey, OUTR) IN (SELECT varchar_nokey, varchar_nokey
FROM BB);
ERROR 42S22: Unknown column 'OUTR' in 'where clause'
DROP TABLE C,BB;
#
# During work with BUG#45863 I had problems with a query that was
# optimized differently in regular and prepared mode.
# Because there was a bug in one of the selected strategies, I became
# aware of the problem. Adding an EXPLAIN  query to catch this.
DROP TABLE IF EXISTS t1, t2, t3;
CREATE TABLE t1
(EMPNUM   CHAR(3) NOT NULL,
EMPNAME  CHAR(20),
GRADE    DECIMAL(4),
CITY     CHAR(15),
UNIQUE KEY t1_IDX(EMPNUM));
CREATE TABLE t2
(PNUM     CHAR(3) NOT NULL,
PNAME    CHAR(20),
PTYPE    CHAR(6),
BUDGET   DECIMAL(9),
CITY     CHAR(15));
CREATE TABLE t3
(EMPNUM   CHAR(3) NOT NULL,
PNUM     CHAR(3) NOT NULL,
HOURS    DECIMAL(5));
INSERT INTO t1 VALUES ('E1','Alice',12,'Deale');
INSERT INTO t1 VALUES ('E2','Betty',10,'Vienna');
INSERT INTO t1 VALUES ('E3','Carmen',13,'Vienna');
INSERT INTO t1 VALUES ('E4','Don',12,'Deale');
INSERT INTO t1 VALUES ('E5','Ed',13,'Akron');
INSERT INTO t2 VALUES ('P1','MXSS','Design',10000,'Deale');
INSERT INTO t2 VALUES ('P2','CALM','Code',30000,'Vienna');
INSERT INTO t2 VALUES ('P3','SDP','Test',30000,'Tampa');
INSERT INTO t2 VALUES ('P4','SDP','Design',20000,'Deale');
INSERT INTO t2 VALUES ('P5','IRM','Test',10000,'Vienna');
INSERT INTO t2 VALUES ('P6','PAYR','Design',50000,'Deale');
INSERT INTO t3 VALUES  ('E1','P1',40);
INSERT INTO t3 VALUES  ('E1','P2',20);
INSERT INTO t3 VALUES  ('E1','P3',80);
INSERT INTO t3 VALUES  ('E1','P4',20);
INSERT INTO t3 VALUES  ('E1','P5',12);
INSERT INTO t3 VALUES  ('E1','P6',12);
INSERT INTO t3 VALUES  ('E2','P1',40);
INSERT INTO t3 VALUES  ('E2','P2',80);
INSERT INTO t3 VALUES  ('E3','P2',20);
INSERT INTO t3 VALUES  ('E4','P2',20);
INSERT INTO t3 VALUES  ('E4','P4',40);
INSERT INTO t3 VALUES  ('E4','P5',80);
DROP INDEX t1_IDX ON t1;
DROP TABLE t1, t2, t3;
#
# BUG#45221 Query SELECT pk FROM C WHERE pk IN (SELECT int_key) failing
#
CREATE TABLE t1 (
i1_key INT,
i2 INT,
i3 INT,
KEY i1_index (i1_key)
);
INSERT INTO t1 VALUES (9,1,2), (9,2,1);
CREATE TABLE t2 (
pk INT NOT NULL,
i1 INT,
PRIMARY KEY (pk)
);
INSERT INTO t2 VALUES (9,1);
SELECT pk
FROM t2
WHERE 
pk IN ( 
SELECT i1_key
FROM t1
WHERE t1.i2 < t1.i3 OR t2.i1 > 1
ORDER BY t1.i2 desc);
pk
9
DROP TABLE t1,t2;
# BUG#50361 Doublenested noncorrelated subquery with FirstMatch and join cache wrong result
#
CREATE TABLE t1(
id INTEGER
);
INSERT INTO t1 VALUES(10),(20);
create table t2 like t1;
insert into t2 select * from t1;
create table t3 like t1;
insert into t3 select * from t1;
SELECT *
FROM t1
WHERE 1 IN(SELECT 1
FROM t2
WHERE 1 IN(SELECT 1
FROM t3));
id
10
20
delete from t2;
delete from t3;
INSERT INTO t1 VALUES(30),(40),(50),(60),(70),(80),(90);
insert into t2 select * from t1;
insert into t3 select * from t1;
create table t4 like t1;
insert into t4 select * from t1;
SELECT *
FROM t1
WHERE 1 IN(SELECT 1
FROM t2
WHERE 1 IN(SELECT 1
FROM t3
WHERE 1 IN(SELECT 1
FROM t4)));
id
10
20
30
40
50
60
70
80
90
SELECT *
FROM t1
WHERE 1 IN(SELECT 1
FROM t1
WHERE 1 IN(SELECT 1
FROM t1
WHERE 1 IN(SELECT 1
FROM t1)));
id
10
20
30
40
50
60
70
80
90
drop table t1,t2,t3,t4;
#
# Bug#53236 Segfault in DTCollation::set(DTCollation&)
#
CREATE TABLE t1 (
pk INTEGER AUTO_INCREMENT,
col_varchar VARCHAR(1),
PRIMARY KEY (pk)
)
;
INSERT INTO t1 (col_varchar) 
VALUES
('w'),
('m')
;
SELECT  table1.pk
FROM ( t1 AS table1 JOIN t1 AS table2 ON (table1.col_varchar =
table2.col_varchar) ) 
WHERE ( 1, 2 ) IN ( SELECT SUBQUERY1_t1.pk AS SUBQUERY1_field1,
SUBQUERY1_t1.pk AS SUBQUERY1_field2
FROM ( t1 AS SUBQUERY1_t1 JOIN t1 AS SUBQUERY1_t2
ON (SUBQUERY1_t2.col_varchar =
SUBQUERY1_t1.col_varchar) ) ) 
;
pk
drop table t1;
#
# BUG#53298 "wrong result with semijoin (no semijoin strategy chosen)"
#
create table t1 (uid int, fid int);
insert into t1 values (1,1), (3,1);
create table t2 (uid int, name varchar(128));
insert into t2 values (1, "A"), (2, "B");
create table t3 (uid int, fid int, index(uid));
insert into t3 values (1,3), (1,3);
create table t4 (uid int);
insert into t4 values (3);
select t2.uid from t2, t1 
where t1.uid in (select t4.uid from t4, t3 where t3.uid=1 and t4.uid=t3.fid)
and t2.uid=t1.fid;
uid
1
drop table t1,t2,t3,t4;
CREATE TABLE t1 (
pk int,
a varchar(1),
b varchar(4),
c varchar(4),
d varchar(4),
PRIMARY KEY (pk)
);
INSERT INTO t1 VALUES (1,'o','ffff','ffff','ffoo'),(2,'f','ffff','ffff','ffff');
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES (1,'i','iiii','iiii','iiii'),(2,'f','ffff','ffff','ffff');
SELECT pk FROM t1 WHERE (a) IN (SELECT a FROM t2 WHERE pk > 0);
pk
2
SELECT pk FROM t1 WHERE (b,c,d) IN (SELECT b,c,d FROM t2 WHERE pk > 0);
pk
2
DROP TABLE t1, t2;
CREATE TABLE t1 (f1 INT, f2 DECIMAL(5,3)) ;
INSERT INTO t1 (f1, f2) VALUES (1, 1.789);
INSERT INTO t1 (f1, f2) VALUES (13, 1.454);
INSERT INTO t1 (f1, f2) VALUES (10, 1.668);
CREATE TABLE t2 LIKE t1;
INSERT INTO t2 VALUES (1, 1.789);
INSERT INTO t2 VALUES (13, 1.454);
SELECT COUNT(*) FROM t1 WHERE (f1,f2) IN (SELECT f1,f2 FROM t2);
COUNT(*)
2
DROP TABLE t1, t2;
CREATE TABLE t1 (
ID int(11) NOT NULL auto_increment,
Name char(35) NOT NULL default '',
Country char(3) NOT NULL default '',
Population int(11) NOT NULL default '0',
PRIMARY KEY  (ID),
INDEX (Population),
INDEX (Country) 
);
CREATE TABLE t2 (
Code char(3) NOT NULL default '',
Name char(52) NOT NULL default '',
SurfaceArea float(10,2) NOT NULL default '0.00',
Population int(11) NOT NULL default '0',
Capital int(11) default NULL,
PRIMARY KEY  (Code),
UNIQUE INDEX (Name),
INDEX (Population)
);
CREATE TABLE t3 (
Country char(3) NOT NULL default '',
Language char(30) NOT NULL default '',
Percentage float(3,1) NOT NULL default '0.0',
PRIMARY KEY  (Country, Language),
INDEX (Percentage)
);
DROP TABLE t1,t2,t3;
CREATE TABLE t1 (
Code char(3) NOT NULL DEFAULT '',
Name char(52) NOT NULL DEFAULT '',
Continent varchar(20) NOT NULL DEFAULT 'Asia',
Region char(26) NOT NULL DEFAULT '',
SurfaceArea float(10,2) NOT NULL DEFAULT '0.00',
IndepYear smallint(6) DEFAULT NULL,
Population int(11) NOT NULL DEFAULT '0',
LifeExpectancy float(3,1) DEFAULT NULL,
GNP float(10,2) DEFAULT NULL,
GNPOld float(10,2) DEFAULT NULL,
LocalName char(45) NOT NULL DEFAULT '',
GovernmentForm char(45) NOT NULL DEFAULT '',
HeadOfState char(60) DEFAULT NULL,
Capital int(11) DEFAULT NULL,
Code2 char(2) NOT NULL DEFAULT '',
PRIMARY KEY (Code)
);
CREATE TABLE t2 (
ID int(11) NOT NULL AUTO_INCREMENT,
Name char(35) NOT NULL DEFAULT '',
CountryCode char(3) NOT NULL DEFAULT '',
District char(20) NOT NULL DEFAULT '',
Population int(11) NOT NULL DEFAULT '0',
PRIMARY KEY (ID),
KEY CountryCode (CountryCode)
);
Fill the table with test data
This must not use LooseScan:
SELECT Name FROM t1 
WHERE t1.Code IN (
SELECT t2.CountryCode FROM t2 WHERE Population > 5000000);
Name
Austria
Canada
China
Czech Republic
drop table t1, t2;
create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4);
create table t1 (a int, b int, key(a));
insert into t1 select a,a from t0;
create table t2 (a int, b int, primary key(a));
insert into t2 select * from t1;
Table t2, unlike table t1, should be displayed as pulled out
update t1 set a=3, b=11 where a=4;
update t2 set b=11 where a=3;
create table tmp like t0;
insert into tmp select * from t0 where t0.a in 
(select t1.a from t1, t2 where t2.a=t0.a and t1.b=t2.b);
create table tmp_as_ref (a int);
insert into tmp_as_ref values(0),(1),(2),(3);
select * from tmp;
a
0
1
2
3
drop table t0, t1, t2, tmp, tmp_as_ref;
CREATE TABLE t1 (
id int(11) NOT NULL,
PRIMARY KEY (id));
CREATE TABLE t2 (
id int(11) NOT NULL,
fid int(11) NOT NULL,
PRIMARY KEY (id));
insert into t1 values(1);
insert into t2 values(1,7503),(2,1);
drop table t1, t2;
create table t1 (a int, b int, key (a), key (b));
insert into t1 values (2,4),(2,4),(2,4);
select t1.a from t1 
where 
t1.a in (select 1 from t1 where t1.a in (select 1 from t1) group by  t1.a);
a
drop table t1;
create table t1(a int,b int,key(a),key(b));
insert into t1 values (1,1),(2,2),(3,3);
select 1 from t1 
where t1.a not in (select 1 from t1 
where t1.a in (select 1 from t1) 
group by  t1.b);
1
1
1
drop table t1;
CREATE TABLE t1
(EMPNUM   CHAR(3) NOT NULL,
EMPNAME  CHAR(20),
GRADE    DECIMAL(4),
CITY     CHAR(15));
CREATE TABLE t2
(PNUM     CHAR(3) NOT NULL,
PNAME    CHAR(20),
PTYPE    CHAR(6),
BUDGET   DECIMAL(9),
CITY     CHAR(15));
CREATE TABLE t3
(EMPNUM   CHAR(3) NOT NULL,
PNUM     CHAR(3) NOT NULL,
HOURS    DECIMAL(5));
INSERT INTO t1 VALUES ('E1','Alice',12,'Deale');
INSERT INTO t1 VALUES ('E2','Betty',10,'Vienna');
INSERT INTO t1 VALUES ('E3','Carmen',13,'Vienna');
INSERT INTO t1 VALUES ('E4','Don',12,'Deale');
INSERT INTO t1 VALUES ('E5','Ed',13,'Akron');
INSERT INTO t2 VALUES ('P1','MXSS','Design',10000,'Deale');
INSERT INTO t2 VALUES ('P2','CALM','Code',30000,'Vienna');
INSERT INTO t2 VALUES ('P3','SDP','Test',30000,'Tampa');
INSERT INTO t2 VALUES ('P4','SDP','Design',20000,'Deale');
INSERT INTO t2 VALUES ('P5','IRM','Test',10000,'Vienna');
INSERT INTO t2 VALUES ('P6','PAYR','Design',50000,'Deale');
INSERT INTO t3 VALUES  ('E1','P1',40);
INSERT INTO t3 VALUES  ('E1','P2',20);
INSERT INTO t3 VALUES  ('E1','P3',80);
INSERT INTO t3 VALUES  ('E1','P4',20);
INSERT INTO t3 VALUES  ('E1','P5',12);
INSERT INTO t3 VALUES  ('E1','P6',12);
INSERT INTO t3 VALUES  ('E2','P1',40);
INSERT INTO t3 VALUES  ('E2','P2',80);
INSERT INTO t3 VALUES  ('E3','P2',20);
INSERT INTO t3 VALUES  ('E4','P2',20);
INSERT INTO t3 VALUES  ('E4','P4',40);
INSERT INTO t3 VALUES  ('E4','P5',80);
SELECT * FROM t1;
EMPNUM	EMPNAME	GRADE	CITY
E1	Alice	12	Deale
E2	Betty	10	Vienna
E3	Carmen	13	Vienna
E4	Don	12	Deale
E5	Ed	13	Akron
CREATE UNIQUE INDEX t1_IDX ON t1(EMPNUM);
SELECT EMPNAME
FROM t1
WHERE EMPNUM IN
(SELECT EMPNUM
FROM t3
WHERE PNUM IN
(SELECT PNUM
FROM t2
WHERE PTYPE = 'Design'));
EMPNAME
Alice
Betty
Don
DROP INDEX t1_IDX ON t1;
CREATE INDEX t1_IDX ON t1(EMPNUM);
SELECT EMPNAME
FROM t1
WHERE EMPNUM IN
(SELECT EMPNUM
FROM t3
WHERE PNUM IN
(SELECT PNUM
FROM t2
WHERE PTYPE = 'Design'));
EMPNAME
Alice
Betty
Don
DROP INDEX t1_IDX ON t1;
SELECT EMPNAME
FROM t1
WHERE EMPNUM IN
(SELECT EMPNUM
FROM t3
WHERE PNUM IN
(SELECT PNUM
FROM t2
WHERE PTYPE = 'Design'));
EMPNAME
Alice
Betty
Don
DROP TABLE t1, t2, t3;
CREATE TABLE t1 (f1 INT NOT NULL);
CREATE VIEW v1 (a) AS SELECT f1 IN (SELECT f1 FROM t1) FROM t1;
SELECT * FROM v1;
a
drop view v1;
drop table t1;
create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1(a int, b int);
insert into t1 values (0,0),(1,1),(2,2);
create table t2 like t1;
insert into t2 select * from t1;
create table t3 (pk int, a int, primary key(pk));
insert into t3 select a,a from t0;
drop table t0, t1, t2, t3;
create table t0 (a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (a int);
insert into t1 select A.a + 10 *(B.a + 10*C.a) as a  from t0 A, t0 B, t0 C;
create table t2 (id int, a int, primary key(id), key(a));
insert into t2 select a as id, a as a  from t1;
set @a=0;
create table t3 like t2;
insert into t3 select * from t2 limit 0;
insert into t3 select @a:=@a+1, t2.a from t2, t0;
insert into t3 select @a:=@a+1, t2.a from t2, t0;
insert into t3 select @a:=@a+1, t2.a from t2, t0;
The following must use loose index scan over t3, key a:
select count(a) from t2 where a in ( SELECT  a FROM t3);
count(a)
1000
drop table t0,t1,t2,t3;
#
# Bug#33062: subquery in stored routine cause crash
#
# 
# Bug#48213 Materialized subselect crashes if using GEOMETRY type
# 
# End of Bug#48213
# 
# BUG#53060: LooseScan semijoin strategy does not return all rows
# 
CREATE TABLE t1 (i INTEGER);
INSERT INTO t1 VALUES (1), (2), (3), (4), (5);
CREATE TABLE t2 (i INTEGER, j INTEGER, KEY k(i, j));
INSERT INTO t2 VALUES (1, 0), (1, 1), (2, 0), (2, 1);
SELECT * FROM t1 WHERE (i) IN (SELECT i FROM t2 where j > 0);
i
1
2
DROP TABLE t1, t2;
# End of BUG#53060
#
# Bug#53305 "Duplicate weedout + join buffer (join cache --level=7,8) loses rows"
#
create table t1 (uid int, fid int, index(uid));
insert into t1 values
(1,1), (1,2), (1,3), (1,4),
(2,5), (2,6), (2,7), (2,8),
(3,1), (3,2), (3,9);
create table t2 (uid int primary key, name varchar(128), index(name));
insert into t2 values 
(1, "A"), (2, "B"), (3, "C"), (4, "D"), (5, "E"),
(6, "F"), (7, "G"), (8, "H"), (9, "I");
create table t3 (uid int, fid int, index(uid));
insert into t3 values
(1,1), (1,2), (1,3),(1,4),
(2,5), (2,6), (2,7), (2,8),
(3,1), (3,2), (3,9);
create table t4 (uid int primary key, name varchar(128), index(name));
insert into t4 values 
(1, "A"), (2, "B"), (3, "C"), (4, "D"), (5, "E"),
(6, "F"), (7, "G"), (8, "H"), (9, "I");
select name from t2, t1 
where t1.uid in (select t4.uid from t4, t3 where t3.uid=1 and t4.uid=t3.fid)
and t2.uid=t1.fid;
name
A
A
B
B
C
D
E
F
G
H
I
drop table t1,t2,t3,t4;
#
# Bug#43768 Prepared query with nested subqueries core dump on second execution
#
CREATE TABLE t1 (
id INT PRIMARY KEY,
partner_id VARCHAR(35)
);
INSERT INTO t1 VALUES
(1, 'partner1'), (2, 'partner2'),
(3, 'partner3'), (4, 'partner4');
CREATE TABLE t2 (
id INT NOT NULL,
t1_line_id INT,
article_id VARCHAR(20),
PRIMARY KEY(id, t1_line_id)
);
INSERT INTO t2 VALUES
(1, 1, 'sup'), (2, 1, 'sup'),
(2, 2, 'sup'), (2, 3, 'sup'),
(2, 4, 'imp'), (3, 1, 'sup'),
(4, 1, 'sup');
CREATE TABLE t3 (
user_id VARCHAR(50),
article_id VARCHAR(20) NOT NULL,
PRIMARY KEY(user_id)
);
INSERT INTO t3 VALUES('nicke', 'imp');
SELECT t1.partner_id
FROM t1
WHERE t1.id IN (
SELECT t2.id
FROM t2
WHERE article_id IN (
SELECT article_id FROM t3
WHERE user_id = 'nicke'
    )
);
partner_id
partner2
DROP TABLE t1,t2,t3;
# End of Bug#43768
#
# Bug#53058 - semijoin execution of subquery with outerjoin yields wrong result
#
CREATE TABLE t1 (i INTEGER);
CREATE TABLE t2 (i INTEGER);
CREATE TABLE t3 (i INTEGER);
INSERT INTO t1 VALUES (1), (2);
INSERT INTO t2 VALUES (6);
INSERT INTO t3 VALUES (1), (2);
SELECT * FROM t1 WHERE (t1.i) IN 
(SELECT t3.i FROM t3 LEFT JOIN t2 ON t2.i=t3.i);
i
1
2
drop table t1,t2,t3;
#
# BUG#49453: re-execution of prepared statement with view 
#            and semijoin crashes
#
CREATE TABLE t1 (city VARCHAR(50), country_id INT);
CREATE TABLE t2 (country_id INT, country VARCHAR(50));
INSERT INTO t1 VALUES 
('Batna',2),('Bchar',2),('Skikda',2),('Tafuna',3),('Algeria',2) ;
INSERT INTO t2 VALUES (2,'Algeria'),(2,'AlgeriaDup'),(3,'XAmerican Samoa');
DROP TABLE t1,t2;
#
# Bug#54437 Extra rows with LEFT JOIN + semijoin (firstmatch
# and duplicates weedout)
#
create table t1 (a int);
create table t2 (a int);
create table t3 (a int);
insert into t1 values(1),(1);
insert into t2 values(1),(1),(1),(1);
insert into t3 values(2),(2);
select * from t1 where t1.a in (select t2.a from t2 left join t3 on t2.a=t3.a);
a
1
1
drop table t1,t2,t3;
#
# BUG#52329 - Wrong result: subquery materialization, IN, 
#             non-null field followed by nullable
#
CREATE TABLE t1 (a1 CHAR(8) NOT NULL, a2 char(8) NOT NULL);
CREATE TABLE t2a (b1 char(8), b2 char(8));
CREATE TABLE t2b (b1 CHAR(8), b2 char(8) NOT NULL);
CREATE TABLE t2c (b1 CHAR(8) NOT NULL, b2 char(8));
INSERT INTO t1 VALUES ('1 - 12', '2 - 22');
INSERT INTO t2a VALUES ('1 - 11', '2 - 21'),
('1 - 11', '2 - 21'),
('1 - 12', '2 - 22'),
('1 - 12', '2 - 22'),
('1 - 13', '2 - 23');
INSERT INTO t2b SELECT * FROM t2a;
INSERT INTO t2c SELECT * FROM t2a;
SELECT * FROM t1
WHERE (a1, a2) IN (
SELECT b1, b2 FROM t2c WHERE b1 > '0' GROUP BY b1, b2);
a1	a2
1 - 12	2 - 22
SELECT * FROM t1
WHERE (a1, a2) IN (
SELECT b1, b2 FROM t2a WHERE b1 > '0');
a1	a2
1 - 12	2 - 22
SELECT * FROM t1
WHERE (a1, a2) IN (
SELECT b1, b2 FROM t2b WHERE b1 > '0');
a1	a2
1 - 12	2 - 22
SELECT * FROM t1
WHERE (a1, a2) IN (
SELECT b1, b2 FROM t2c WHERE b1 > '0');
a1	a2
1 - 12	2 - 22
DROP TABLE t1,t2a,t2b,t2c;
# End BUG#52329
#
# Bug#45174: Incorrectly applied equality propagation caused wrong
# result on a query with a materialized semi-join.
#
CREATE TABLE t1 (
varchar_nokey varchar(1) NOT NULL
);
INSERT INTO t1 VALUES
('v'), ('u'), ('n'), ('l'), ('h'), ('u'), ('n'), ('j'), ('k'),
('e'), ('i'), ('u'), ('n'), ('b'), ('x'), (''), ('q'), ('u');
CREATE TABLE t2 (
pk int NOT NULL,
varchar_key varchar(1) NOT NULL,
varchar_nokey varchar(1) NOT NULL,
PRIMARY KEY(pk),
KEY varchar_key(varchar_key)
);
INSERT INTO t2 VALUES
(11,'m','m'), (12,'j','j'), (13,'z','z'), (14,'a','a'), (15,'',''),
(16,'e','e'), (17,'t','t'), (19,'b','b'), (20,'w','w'), (21,'m','m'),
(23,'',''), (24,'w','w'), (26,'e','e'), (27,'e','e'), (28,'p','p');
SELECT varchar_nokey
FROM t1
WHERE (varchar_nokey, varchar_nokey) IN (SELECT varchar_key, varchar_nokey
FROM t2  
WHERE varchar_nokey < 'n' OR pk);
varchar_nokey
j
e
b

DROP TABLE t1, t2;
# End of the test for bug#45174.
#
# Bug#50019: Wrong result for IN-query with materialization
#
CREATE TABLE t1(i INT);
INSERT INTO t1 VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
CREATE TABLE t2(i INT);
INSERT INTO t2 VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
CREATE TABLE t3(i INT);
INSERT INTO t3 VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10);
SELECT * FROM t1 WHERE t1.i IN (SELECT t2.i
FROM t2 JOIN t3
WHERE t2.i + t3.i = 5);
i
1
2
3
4
DROP TABLE t1,t2,t3;
# End of the test for bug#50019.
#
# Bug#52068: Optimizer generates invalid semijoin materialization plan
#
CREATE TABLE ot1(a INTEGER);
INSERT INTO ot1 VALUES(5), (8);
CREATE TABLE it2(a INTEGER);
INSERT INTO it2 VALUES(9), (5), (1), (8);
CREATE TABLE it3(a INTEGER);
INSERT INTO it3 VALUES(7), (1), (0), (5), (1), (4);
CREATE TABLE ot4(a INTEGER);
INSERT INTO ot4 VALUES(1), (3), (5), (7), (9), (7), (3), (1);
SELECT * FROM ot1,ot4
WHERE (ot1.a,ot4.a) IN (SELECT it2.a,it3.a
FROM it2,it3);
a	a
5	1
5	1
5	5
8	1
8	1
8	5
8	7
8	7
5	7
5	7
DROP TABLE IF EXISTS ot1, ot4, it2, it3;
# End of the test for bug#52068.
#
# Bug#57623: subquery within before insert trigger causes crash (sj=on)
#
CREATE TABLE ot1(a INT);
CREATE TABLE ot2(a INT);
CREATE TABLE ot3(a INT);
CREATE TABLE it1(a INT);
INSERT INTO ot1 VALUES(0),(1),(2),(3),(4),(5),(6),(7);
INSERT INTO ot2 VALUES(0),(2),(4),(6);
INSERT INTO ot3 VALUES(0),(3),(6);
INSERT INTO it1 VALUES(0),(1),(2),(3),(4),(5),(6),(7);
SELECT *
FROM   ot1
LEFT JOIN
(ot2 JOIN ot3 on ot2.a=ot3.a)
ON ot1.a=ot2.a WHERE ot1.a IN (SELECT a from it1);
a	a	a
0	0	0
1	NULL	NULL
2	NULL	NULL
3	NULL	NULL
4	NULL	NULL
5	NULL	NULL
6	6	6
7	NULL	NULL
DROP TABLE ot1, ot2, ot3, it1;
# End of the test for bug#57623.
#
# Bug#11766739: Crash in tmp_table_param::init() with semijoin=on
#
CREATE TABLE t1 (f1 INTEGER) ;
CREATE TABLE t2 (f1 INTEGER, f2 INTEGER) ;
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (1,1), (2,1);
SELECT * FROM t2
WHERE f2 IN (SELECT t1.f1
FROM t1 LEFT OUTER JOIN (t2 AS b1 JOIN t2 AS b2 ON TRUE) ON TRUE);
f1	f2
2	1
1	1
DROP TABLE t1, t2;
# End of the test for bug#11766739.
#
# Bug#11766642: crash in Item_field::register_field_in_read_map with view
#
CREATE TABLE t1(a INT);
CREATE VIEW v1 AS SELECT a FROM t1;
INSERT INTO t1 VALUES (0),(1),(2);
SELECT a FROM t1 WHERE a IN 
(SELECT a OR a FROM v1)
ORDER BY a;
a
0
1
DROP TABLE t1;
DROP VIEW v1;
#
# Bug#12546542 MISSING ROW WHEN USING OPTIMIZER_JOIN_CACHE_LEVEL>=3
#
CREATE TABLE t1 (
f2 varchar(1024)
);
INSERT INTO t1 VALUES ('v'),('we');
CREATE TABLE t2 (
col_varchar_1024_utf8 varchar(1024) CHARACTER SET utf8 DEFAULT NULL,
col_int_key int,
col_int int
);
INSERT INTO t2 VALUES ('we',4,NULL),('v',1305673728,6);
CREATE TABLE t3 (
col_int_key int,
col_int int
);
INSERT INTO t3 VALUES (4,4);
SELECT *
FROM t1
WHERE f2 IN (SELECT a1.col_varchar_1024_utf8 AS f2
FROM t2 AS a1 LEFT JOIN t3 AS a2
ON a1.col_int_key = a2.col_int_key
WHERE a1.col_int BETWEEN 1 AND 10 OR a2.col_int IS NOT NULL);
f2
we
v
DROP TABLE t1,t2,t3;
#
# BUG#12616344 - JCL: DIFFERENT RESULT SET AND DIFFERENT AMOUNT
# OF ROWS WHEN JCL>=3
#
CREATE TABLE t1 (col_int_nokey int, col_int_key int, col_varchar_key varchar(1));
INSERT INTO t1 VALUES (0,4,'c'),(1,6,'u');
CREATE TABLE t2 (pk int, col_int_nokey int, col_varchar_nokey varchar(1));
INSERT INTO t2 VALUES (1,4,'b'),(94,6,'u');
CREATE TABLE t3 (pk int, col_int_nokey int, col_varchar_key varchar(1));
INSERT INTO t3 VALUES (1,4,'j'),(2,6,'v');
SELECT table2.col_int_key
from t3 as table1 join t1 as table2 on table2.col_int_nokey 
where table1.col_int_nokey in 
( 
select subquery2_t2.col_int_nokey 
from t3 as subquery2_t1 
right join
(t2 as subquery2_t2
join t1 as subquery2_t3
on subquery2_t3.col_int_key = subquery2_t2.col_int_nokey)
on subquery2_t3.col_varchar_key = subquery2_t2.col_varchar_nokey 
where subquery2_t1.col_varchar_key != table1.col_varchar_key
or subquery2_t2.pk <= table1.pk
);
col_int_key
6
6
DROP TABLE t1,t2,t3;
#
# Bug#12608157: ASSERT IN FIELD_LONG::VAL_INT WHEN USING MEMORY ENGINE
#
CREATE TABLE t1 (i1 int);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (i1 int, i2 int) ;
INSERT INTO t2 VALUES (1, 2),(7, 3);
SELECT GRANDPARENT1.i1
FROM t2 AS GRANDPARENT1 
WHERE GRANDPARENT1.i2
IN ( SELECT PARENT1.i2
FROM t2 AS PARENT1 JOIN t1 AS PARENT2 ON (PARENT1.i1 = PARENT2.i1)
WHERE 
GRANDPARENT1.i1 IN ( SELECT CHILD1.i1 FROM t2 AS CHILD1 )
ORDER BY PARENT1.i1)
ORDER BY GRANDPARENT1.i2 ;
i1
1
DROP TABLE t1,t2;
#
# Bug#12640083: Same query executed as WHERE subquery gives different
#              results on IN() compare
#
CREATE TABLE t1 (
pk int NOT NULL,
col_varchar_1024_utf8_key varchar(128) CHARACTER SET utf8 DEFAULT NULL,
col_varchar_10_utf8_key varchar(10) DEFAULT NULL,
PRIMARY KEY (pk),
KEY col_varchar_1024_utf8_key(col_varchar_1024_utf8_key),
KEY col_varchar_10_utf8_key(col_varchar_10_utf8_key)
);
INSERT INTO t1 VALUES
(1, 'a', 'a'),
(2, 'ab', 'ab'),
(3, 'abc', 'abc'),
(4, 'abcd', 'abcd');
CREATE TABLE t2 (
pk int NOT NULL AUTO_INCREMENT,
PRIMARY KEY (pk)
) ;
CREATE TABLE t3(col_varchar_10_utf8_key varchar(10));
INSERT INTO t3 SELECT alias1.col_varchar_10_utf8_key
FROM t1 AS alias1
LEFT JOIN (t1 AS alias2
JOIN t2 AS alias3
ON alias2.col_varchar_10_utf8_key)
ON alias1.col_varchar_1024_utf8_key
WHERE alias1.pk AND alias1.pk < 3 OR alias1.pk AND alias3.pk;
SELECT * 
FROM t3 
WHERE col_varchar_10_utf8_key IN (
SELECT alias1.col_varchar_10_utf8_key 
FROM t1 AS alias1
LEFT JOIN (t1 AS alias2
JOIN t2 AS alias3
ON alias2.col_varchar_10_utf8_key)
ON alias1.col_varchar_1024_utf8_key
WHERE alias1.pk AND alias1.pk < 3 OR alias1.pk AND alias3.pk);
col_varchar_10_utf8_key
a
ab
DROP TABLE t1, t2, t3;
